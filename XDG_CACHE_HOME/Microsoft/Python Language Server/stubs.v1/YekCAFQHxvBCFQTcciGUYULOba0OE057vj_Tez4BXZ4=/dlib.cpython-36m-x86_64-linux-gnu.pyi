import pybind11_builtins as _mod_pybind11_builtins

DLIB_USE_BLAS = True
DLIB_USE_CUDA = False
DLIB_USE_LAPACK = True
USE_AVX_INSTRUCTIONS = False
USE_NEON_INSTRUCTIONS = False
__doc__ = None
__file__ = '/home/lucas/anaconda3/envs/curso_dlib/lib/python3.6/site-packages/dlib.cpython-36m-x86_64-linux-gnu.so'
__name__ = 'dlib'
__package__ = ''
__time_compiled__ = 'Apr 10 2018 19:15:18'
__version__ = '19.10.0'
class _binary_test(_mod_pybind11_builtins.pybind11_object):
    __class__ = _binary_test
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib._binary_test):
        '__repr__(self: dlib._binary_test) -> str\n'
        return ''
    
    def __str__(self: dlib._binary_test):
        '__str__(self: dlib._binary_test) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    class1_accuracy = _mod_builtins.property()
    class2_accuracy = _mod_builtins.property()

class _decision_function_histogram_intersection(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_histogram_intersection, arg0: dlib.vector):
        '__call__(self: dlib._decision_function_histogram_intersection, arg0: dlib.vector) -> float\n'
        pass
    
    __class__ = _decision_function_histogram_intersection
    def __getstate__(self: dlib._decision_function_histogram_intersection):
        '__getstate__(self: dlib._decision_function_histogram_intersection) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_histogram_intersection, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _decision_function_linear(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_linear, arg0: dlib.vector):
        '__call__(self: dlib._decision_function_linear, arg0: dlib.vector) -> float\n'
        pass
    
    __class__ = _decision_function_linear
    def __getstate__(self: dlib._decision_function_linear):
        '__getstate__(self: dlib._decision_function_linear) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_linear, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    bias = _mod_builtins.property()
    weights = _mod_builtins.property()

class _decision_function_polynomial(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_polynomial, arg0: dlib.vector):
        '__call__(self: dlib._decision_function_polynomial, arg0: dlib.vector) -> float\n'
        pass
    
    __class__ = _decision_function_polynomial
    def __getstate__(self: dlib._decision_function_polynomial):
        '__getstate__(self: dlib._decision_function_polynomial) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_polynomial, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _decision_function_radial_basis(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_radial_basis, arg0: dlib.vector):
        '__call__(self: dlib._decision_function_radial_basis, arg0: dlib.vector) -> float\n'
        pass
    
    __class__ = _decision_function_radial_basis
    def __getstate__(self: dlib._decision_function_radial_basis):
        '__getstate__(self: dlib._decision_function_radial_basis) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_radial_basis, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _decision_function_sigmoid(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_sigmoid, arg0: dlib.vector):
        '__call__(self: dlib._decision_function_sigmoid, arg0: dlib.vector) -> float\n'
        pass
    
    __class__ = _decision_function_sigmoid
    def __getstate__(self: dlib._decision_function_sigmoid):
        '__getstate__(self: dlib._decision_function_sigmoid) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_sigmoid, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _decision_function_sparse_histogram_intersection(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_sparse_histogram_intersection, arg0: dlib.sparse_vector):
        '__call__(self: dlib._decision_function_sparse_histogram_intersection, arg0: dlib.sparse_vector) -> float\n'
        pass
    
    __class__ = _decision_function_sparse_histogram_intersection
    def __getstate__(self: dlib._decision_function_sparse_histogram_intersection):
        '__getstate__(self: dlib._decision_function_sparse_histogram_intersection) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_sparse_histogram_intersection, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _decision_function_sparse_linear(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_sparse_linear, arg0: dlib.sparse_vector):
        '__call__(self: dlib._decision_function_sparse_linear, arg0: dlib.sparse_vector) -> float\n'
        pass
    
    __class__ = _decision_function_sparse_linear
    def __getstate__(self: dlib._decision_function_sparse_linear):
        '__getstate__(self: dlib._decision_function_sparse_linear) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_sparse_linear, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    bias = _mod_builtins.property()
    weights = _mod_builtins.property()

class _decision_function_sparse_polynomial(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_sparse_polynomial, arg0: dlib.sparse_vector):
        '__call__(self: dlib._decision_function_sparse_polynomial, arg0: dlib.sparse_vector) -> float\n'
        pass
    
    __class__ = _decision_function_sparse_polynomial
    def __getstate__(self: dlib._decision_function_sparse_polynomial):
        '__getstate__(self: dlib._decision_function_sparse_polynomial) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_sparse_polynomial, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _decision_function_sparse_radial_basis(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_sparse_radial_basis, arg0: dlib.sparse_vector):
        '__call__(self: dlib._decision_function_sparse_radial_basis, arg0: dlib.sparse_vector) -> float\n'
        pass
    
    __class__ = _decision_function_sparse_radial_basis
    def __getstate__(self: dlib._decision_function_sparse_radial_basis):
        '__getstate__(self: dlib._decision_function_sparse_radial_basis) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_sparse_radial_basis, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _decision_function_sparse_sigmoid(_mod_pybind11_builtins.pybind11_object):
    def __call__(self: dlib._decision_function_sparse_sigmoid, arg0: dlib.sparse_vector):
        '__call__(self: dlib._decision_function_sparse_sigmoid, arg0: dlib.sparse_vector) -> float\n'
        pass
    
    __class__ = _decision_function_sparse_sigmoid
    def __getstate__(self: dlib._decision_function_sparse_sigmoid):
        '__getstate__(self: dlib._decision_function_sparse_sigmoid) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib._decision_function_sparse_sigmoid, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class _range_iter(_mod_pybind11_builtins.pybind11_object):
    __class__ = _range_iter
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __next__(self: dlib._range_iter):
        '__next__(self: dlib._range_iter) -> int\n'
        pass
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def next(self: dlib._range_iter):
        'next(self: dlib._range_iter) -> int\n'
        return 1
    

class _ranking_test(_mod_pybind11_builtins.pybind11_object):
    __class__ = _ranking_test
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib._ranking_test):
        '__repr__(self: dlib._ranking_test) -> str\n'
        return ''
    
    def __str__(self: dlib._ranking_test):
        '__str__(self: dlib._ranking_test) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    mean_ap = _mod_builtins.property()
    ranking_accuracy = _mod_builtins.property()

class _regression_test(_mod_pybind11_builtins.pybind11_object):
    R_squared = _mod_builtins.property()
    __class__ = _regression_test
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib._regression_test):
        '__repr__(self: dlib._regression_test) -> str\n'
        return ''
    
    def __str__(self: dlib._regression_test):
        '__str__(self: dlib._regression_test) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    mean_average_error = _mod_builtins.property()
    mean_error_stddev = _mod_builtins.property()
    mean_squared_error = _mod_builtins.property()

class _row(_mod_pybind11_builtins.pybind11_object):
    __class__ = _row
    def __getitem__(self, index):
        '__getitem__(self: dlib._row, arg0: int) -> float\n'
        pass
    
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __len__(self: dlib._row):
        '__len__(self: dlib._row) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __repr__(self: dlib._row):
        '__repr__(self: dlib._row) -> str\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(self: dlib._row, arg0: int, arg1: float) -> None\n'
        return None
    
    def __str__(self: dlib._row):
        '__str__(self: dlib._row) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

def apply_cca_transform(m: dlib.matrix, v: dlib.sparse_vector):
    'apply_cca_transform(m: dlib.matrix, v: dlib.sparse_vector) -> dlib.vector\n\nrequires    \n    - max_index_plus_one(v) <= m.nr()    \nensures    \n    - returns trans(m)*v    \n      (i.e. multiply m by the vector v and return the result)   \n'
    pass

class array(_mod_pybind11_builtins.pybind11_object):
    'This object represents a 1D array of floating point numbers. Moreover, it binds directly to the C++ type std::vector<double>.'
    def __bool__(self: dlib.array):
        '__bool__(self: dlib.array) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = array
    def __contains__(self, value):
        '__contains__(self: dlib.array, x: float) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.array, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.array, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.array, arg0: dlib.array):
        '__eq__(self: dlib.array, arg0: dlib.array) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.array, s: slice) -> dlib.array\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.array, arg0: int) -> float\n'
        pass
    
    def __getstate__(self: dlib.array):
        '__getstate__(self: dlib.array) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.array) -> None\n\n2. __init__(self: dlib.array, arg0: dlib.array) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.array, arg0: iterable) -> None\n\n4. __init__(self: dlib.array, arg0: object) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.array):
        '__iter__(self: dlib.array) -> iterator\n'
        return array()
    
    def __len__(self: dlib.array):
        '__len__(self: dlib.array) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.array, arg0: dlib.array):
        '__ne__(self: dlib.array, arg0: dlib.array) -> bool\n'
        return False
    
    __pybind11_module_local_v1__ = _mod_builtins.PyCapsule()
    def __repr__(self, *args, **kwargs):
        '__repr__(*args, **kwargs)\nOverloaded function.\n\n1. __repr__(self: dlib.array) -> str\n\nReturn the canonical string representation of this list.\n\n2. __repr__(self: dlib.array) -> str\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.array, arg0: int, arg1: float) -> None\n\n2. __setitem__(self: dlib.array, arg0: slice, arg1: dlib.array) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.array, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.array):
        '__str__(self: dlib.array) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.array, x: float):
        'append(self: dlib.array, x: float) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.array):
        'clear(self: dlib.array) -> None\n'
        pass
    
    def count(self: dlib.array, x: float):
        'count(self: dlib.array, x: float) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.array, L: dlib.array) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.array, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.array, i: int, x: float):
        'insert(self: dlib.array, i: int, x: float) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.array) -> float\n\nRemove and return the last item\n\n2. pop(self: dlib.array, i: int) -> float\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.array, x: float):
        'remove(self: dlib.array, x: float) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.array, arg0: int):
        'resize(self: dlib.array, arg0: int) -> None\n'
        pass
    

def assignment_cost(cost: dlib.matrix, assignment: list):
    'assignment_cost(cost: dlib.matrix, assignment: list) -> float\n\nrequires    \n    - cost.nr() == cost.nc()    \n      (i.e. the input must be a square matrix)    \n    - for all valid i:    \n        - 0 <= assignment[i] < cost.nr()    \nensures    \n    - Interprets cost as a cost assignment matrix. That is, cost[i][j]     \n      represents the cost of assigning i to j.      \n    - Interprets assignment as a particular set of assignments. That is,    \n      i is assigned to assignment[i].    \n    - returns the cost of the given assignment. That is, returns    \n      a number which is:    \n        sum over i: cost[i][assignment[i]]   \n'
    return 1.0

def cca(L: dlib.sparse_vectors, R: dlib.sparse_vectors, num_correlations: int, extra_rank: int=5, q: int=2, regularization: float=0):
    'cca(L: dlib.sparse_vectors, R: dlib.sparse_vectors, num_correlations: int, extra_rank: int=5, q: int=2, regularization: float=0) -> dlib.cca_outputs\n\nrequires    \n    - num_correlations > 0    \n    - len(L) > 0     \n    - len(R) > 0     \n    - len(L) == len(R)    \n    - regularization >= 0    \n    - L and R must be properly sorted sparse vectors.  This means they must list their  \n      elements in ascending index order and not contain duplicate index values.  You can use \n      make_sparse_vector() to ensure this is true.  \nensures    \n    - This function performs a canonical correlation analysis between the vectors    \n      in L and R.  That is, it finds two transformation matrices, Ltrans and    \n      Rtrans, such that row vectors in the transformed matrices L*Ltrans and    \n      R*Rtrans are as correlated as possible (note that in this notation we    \n      interpret L as a matrix with the input vectors in its rows).  Note also that    \n      this function tries to find transformations which produce num_correlations    \n      dimensional output vectors.    \n    - Note that you can easily apply the transformation to a vector using     \n      apply_cca_transform().  So for example, like this:     \n        - apply_cca_transform(Ltrans, some_sparse_vector)    \n    - returns a structure containing the Ltrans and Rtrans transformation matrices    \n      as well as the estimated correlations between elements of the transformed    \n      vectors.    \n    - This function assumes the data vectors in L and R have already been centered    \n      (i.e. we assume the vectors have zero means).  However, in many cases it is    \n      fine to use uncentered data with cca().  But if it is important for your    \n      problem then you should center your data before passing it to cca().   \n    - This function works with reduced rank approximations of the L and R matrices.    \n      This makes it fast when working with large matrices.  In particular, we use    \n      the dlib::svd_fast() routine to find reduced rank representations of the input    \n      matrices by calling it as follows: svd_fast(L, U,D,V, num_correlations+extra_rank, q)     \n      and similarly for R.  This means that you can use the extra_rank and q    \n      arguments to cca() to influence the accuracy of the reduced rank    \n      approximation.  However, the default values should work fine for most    \n      problems.    \n    - The dimensions of the output vectors produced by L*#Ltrans or R*#Rtrans are \n      ordered such that the dimensions with the highest correlations come first. \n      That is, after applying the transforms produced by cca() to a set of vectors \n      you will find that dimension 0 has the highest correlation, then dimension 1 \n      has the next highest, and so on.  This also means that the list of estimated \n      correlations returned from cca() will always be listed in decreasing order. \n    - This function performs the ridge regression version of Canonical Correlation    \n      Analysis when regularization is set to a value > 0.  In particular, larger    \n      values indicate the solution should be more heavily regularized.  This can be    \n      useful when the dimensionality of the data is larger than the number of    \n      samples.    \n    - A good discussion of CCA can be found in the paper "Canonical Correlation    \n      Analysis" by David Weenink.  In particular, this function is implemented    \n      using equations 29 and 30 from his paper.  We also use the idea of doing CCA    \n      on a reduced rank approximation of L and R as suggested by Paramveer S.    \n      Dhillon in his paper "Two Step CCA: A new spectral method for estimating    \n      vector models of words".   \n'
    pass

class cca_outputs(_mod_pybind11_builtins.pybind11_object):
    Ltrans = _mod_builtins.property()
    Rtrans = _mod_builtins.property()
    __class__ = cca_outputs
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    correlations = _mod_builtins.property()

def chinese_whispers_clustering(descriptors: list, threshold: float):
    'chinese_whispers_clustering(descriptors: list, threshold: float) -> list\n\nTakes a list of descriptors and returns a list that contains a label for each descriptor. Clustering is done using dlib::chinese_whispers.\n'
    return list()

class cnn_face_detection_model_v1(_mod_pybind11_builtins.pybind11_object):
    'This object detects human faces in an image.  The constructor loads the face detection model from a file. You can download a pre-trained model from http://dlib.net/files/mmod_human_face_detector.dat.bz2.'
    def __call__(self, *args, **kwargs):
        '__call__(*args, **kwargs)\nOverloaded function.\n\n1. __call__(self: dlib.cnn_face_detection_model_v1, imgs: list, upsample_num_times: int=0, batch_size: int=128) -> std::vector<std::vector<dlib::mmod_rect, std::allocator<dlib::mmod_rect> >, std::allocator<std::vector<dlib::mmod_rect, std::allocator<dlib::mmod_rect> > > >\n\ntakes a list of images as input returning a 2d list of mmod rectangles\n\n2. __call__(self: dlib.cnn_face_detection_model_v1, img: object, upsample_num_times: int=0) -> std::vector<dlib::mmod_rect, std::allocator<dlib::mmod_rect> >\n\nFind faces in an image using a deep learning model.\n          - Upsamples the image upsample_num_times before running the face \n            detector.\n'
        pass
    
    __class__ = cnn_face_detection_model_v1
    def __init__(self: dlib.cnn_face_detection_model_v1, arg0: str):
        '__init__(self: dlib.cnn_face_detection_model_v1, arg0: str) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    

class correlation_tracker(_mod_pybind11_builtins.pybind11_object):
    "This is a tool for tracking moving objects in a video stream.  You give it \n            the bounding box of an object in the first frame and it attempts to track the \n            object in the box from frame to frame.  \n            This tool is an implementation of the method described in the following paper: \n                Danelljan, Martin, et al. 'Accurate scale estimation for robust visual \n                tracking.' Proceedings of the British Machine Vision Conference BMVC. 2014."
    __class__ = correlation_tracker
    def __init__(self: dlib.correlation_tracker):
        '__init__(self: dlib.correlation_tracker) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def get_position(self: dlib.correlation_tracker):
        'get_position(self: dlib.correlation_tracker) -> dlib.drectangle\n\nreturns the predicted position of the object under track.\n'
        pass
    
    def start_track(self, *args, **kwargs):
        'start_track(*args, **kwargs)\nOverloaded function.\n\n1. start_track(self: dlib.correlation_tracker, image: object, bounding_box: dlib.drectangle) -> None\n\n            requires \n                - image is a numpy ndarray containing either an 8bit grayscale or RGB image. \n                - bounding_box.is_empty() == false \n            ensures \n                - This object will start tracking the thing inside the bounding box in the \n                  given image.  That is, if you call update() with subsequent video frames \n                  then it will try to keep track of the position of the object inside bounding_box. \n                - #get_position() == bounding_box\n\n2. start_track(self: dlib.correlation_tracker, image: object, bounding_box: dlib.rectangle) -> None\n\n            requires \n                - image is a numpy ndarray containing either an 8bit grayscale or RGB image. \n                - bounding_box.is_empty() == false \n            ensures \n                - This object will start tracking the thing inside the bounding box in the \n                  given image.  That is, if you call update() with subsequent video frames \n                  then it will try to keep track of the position of the object inside bounding_box. \n                - #get_position() == bounding_box\n'
        pass
    
    def update(self, *args, **kwargs):
        'update(*args, **kwargs)\nOverloaded function.\n\n1. update(self: dlib.correlation_tracker, image: object) -> float\n\n            requires \n                - image is a numpy ndarray containing either an 8bit grayscale or RGB image. \n                - get_position().is_empty() == false \n                  (i.e. you must have started tracking by calling start_track()) \n            ensures \n                - performs: return update(img, get_position())\n\n2. update(self: dlib.correlation_tracker, image: object, guess: dlib.drectangle) -> float\n\n            requires \n                - image is a numpy ndarray containing either an 8bit grayscale or RGB image. \n                - get_position().is_empty() == false \n                  (i.e. you must have started tracking by calling start_track()) \n            ensures \n                - When searching for the object in img, we search in the area around the \n                  provided guess. \n                - #get_position() == the new predicted location of the object in img.  This \n                  location will be a copy of guess that has been translated and scaled \n                  appropriately based on the content of img so that it, hopefully, bounds \n                  the object in img. \n                - Returns the peak to side-lobe ratio.  This is a number that measures how \n                  confident the tracker is that the object is inside #get_position(). \n                  Larger values indicate higher confidence.\n\n3. update(self: dlib.correlation_tracker, image: object, guess: dlib.rectangle) -> float\n\n            requires \n                - image is a numpy ndarray containing either an 8bit grayscale or RGB image. \n                - get_position().is_empty() == false \n                  (i.e. you must have started tracking by calling start_track()) \n            ensures \n                - When searching for the object in img, we search in the area around the \n                  provided guess. \n                - #get_position() == the new predicted location of the object in img.  This \n                  location will be a copy of guess that has been translated and scaled \n                  appropriately based on the content of img so that it, hopefully, bounds \n                  the object in img. \n                - Returns the peak to side-lobe ratio.  This is a number that measures how \n                  confident the tracker is that the object is inside #get_position(). \n                  Larger values indicate higher confidence.\n'
        pass
    

def count_steps_without_decrease(time_series: object, probability_of_decrease: float=0.51):
    'count_steps_without_decrease(time_series: object, probability_of_decrease: float=0.51) -> int\n\nrequires \n    - time_series must be a one dimensional array of real numbers.  \n    - 0.5 < probability_of_decrease < 1 \nensures \n    - If you think of the contents of time_series as a potentially noisy time \n      series, then this function returns a count of how long the time series has \n      gone without noticeably decreasing in value.  It does this by scanning along \n      the elements, starting from the end (i.e. time_series[-1]) to the beginning, \n      and checking how many elements you need to examine before you are confident \n      that the series has been decreasing in value.  Here, "confident of decrease" \n      means the probability of decrease is >= probability_of_decrease.   \n    - Setting probability_of_decrease to 0.51 means we count until we see even a \n      small hint of decrease, whereas a larger value of 0.99 would return a larger \n      count since it keeps going until it is nearly certain the time series is \n      decreasing. \n    - The max possible output from this function is len(time_series). \n    - The implementation of this function is done using the dlib::running_gradient \n      object, which is a tool that finds the least squares fit of a line to the \n      time series and the confidence interval around the slope of that line.  That \n      can then be used in a simple statistical test to determine if the slope is \n      positive or negative.\n'
    return 1

def count_steps_without_decrease_robust(time_series: object, probability_of_decrease: float=0.51, quantile_discard: float=0.1):
    'count_steps_without_decrease_robust(time_series: object, probability_of_decrease: float=0.51, quantile_discard: float=0.1) -> int\n\nrequires \n    - time_series must be a one dimensional array of real numbers.  \n    - 0.5 < probability_of_decrease < 1 \n    - 0 <= quantile_discard <= 1 \nensures \n    - This function behaves just like \n      count_steps_without_decrease(time_series,probability_of_decrease) except that \n      it ignores values in the time series that are in the upper quantile_discard \n      quantile.  So for example, if the quantile discard is 0.1 then the 10% \n      largest values in the time series are ignored.\n'
    return 1

def cross_validate_ranking_trainer(*args, **kwargs):
    'cross_validate_ranking_trainer(*args, **kwargs)\nOverloaded function.\n\n1. cross_validate_ranking_trainer(trainer: dlib.svm_rank_trainer, samples: dlib.ranking_pairs, folds: int) -> ranking_test\n\n2. cross_validate_ranking_trainer(trainer: dlib.svm_rank_trainer_sparse, samples: dlib.sparse_ranking_pairs, folds: int) -> ranking_test\n'
    pass

def cross_validate_sequence_segmenter(*args, **kwargs):
    'cross_validate_sequence_segmenter(*args, **kwargs)\nOverloaded function.\n\n1. cross_validate_sequence_segmenter(samples: dlib.vectorss, segments: dlib.rangess, folds: int, params: dlib.segmenter_params=<BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100>) -> dlib.segmenter_test\n\n2. cross_validate_sequence_segmenter(samples: dlib.sparse_vectorss, segments: dlib.rangess, folds: int, params: dlib.segmenter_params=<BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100>) -> dlib.segmenter_test\n'
    pass

def cross_validate_trainer(*args, **kwargs):
    'cross_validate_trainer(*args, **kwargs)\nOverloaded function.\n\n1. cross_validate_trainer(trainer: dlib.svm_c_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n2. cross_validate_trainer(trainer: dlib.svm_c_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n3. cross_validate_trainer(trainer: dlib.svm_c_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n4. cross_validate_trainer(trainer: dlib.svm_c_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n5. cross_validate_trainer(trainer: dlib.svm_c_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n6. cross_validate_trainer(trainer: dlib.svm_c_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n7. cross_validate_trainer(trainer: dlib.rvm_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n8. cross_validate_trainer(trainer: dlib.rvm_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n9. cross_validate_trainer(trainer: dlib.rvm_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n10. cross_validate_trainer(trainer: dlib.rvm_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n11. cross_validate_trainer(trainer: dlib.rvm_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int) -> dlib._binary_test\n\n12. cross_validate_trainer(trainer: dlib.rvm_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int) -> dlib._binary_test\n'
    pass

def cross_validate_trainer_threaded(*args, **kwargs):
    'cross_validate_trainer_threaded(*args, **kwargs)\nOverloaded function.\n\n1. cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n2. cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n3. cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n4. cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n5. cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n6. cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n7. cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n8. cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n9. cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n10. cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n11. cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n\n12. cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -> dlib._binary_test\n'
    pass

def dot(arg0: dlib.vector, arg1: dlib.vector):
    'dot(arg0: dlib.vector, arg1: dlib.vector) -> float\n\nCompute the dot product between two dense column vectors.\n'
    return 1.0

class drectangle(_mod_pybind11_builtins.pybind11_object):
    'This object represents a rectangular area of an image with floating point coordinates.'
    __class__ = drectangle
    def __eq__(self: dlib.drectangle, arg0: dlib.drectangle):
        '__eq__(self: dlib.drectangle, arg0: dlib.drectangle) -> bool\n'
        return False
    
    def __getstate__(self: dlib.drectangle):
        '__getstate__(self: dlib.drectangle) -> tuple\n'
        pass
    
    def __init__(self: dlib.drectangle, left: float, top: float, right: float, bottom: float):
        '__init__(self: dlib.drectangle, left: float, top: float, right: float, bottom: float) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __ne__(self: dlib.drectangle, arg0: dlib.drectangle):
        '__ne__(self: dlib.drectangle, arg0: dlib.drectangle) -> bool\n'
        return False
    
    def __repr__(self: dlib.drectangle):
        '__repr__(self: dlib.drectangle) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.drectangle, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.drectangle):
        '__str__(self: dlib.drectangle) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def area(self: dlib.drectangle):
        'area(self: dlib.drectangle) -> float\n'
        return 1.0
    
    def bottom(self: dlib.drectangle):
        'bottom(self: dlib.drectangle) -> float\n'
        return 1.0
    
    def center(self: dlib.drectangle):
        'center(self: dlib.drectangle) -> dlib.point\n'
        pass
    
    def contains(self, *args, **kwargs):
        'contains(*args, **kwargs)\nOverloaded function.\n\n1. contains(self: dlib.drectangle, point: dlib.point) -> bool\n\n2. contains(self: dlib.drectangle, x: int, y: int) -> bool\n\n3. contains(self: dlib.drectangle, rectangle: dlib.drectangle) -> bool\n'
        pass
    
    def dcenter(self: dlib.drectangle):
        'dcenter(self: dlib.drectangle) -> dlib.point\n'
        pass
    
    def height(self: dlib.drectangle):
        'height(self: dlib.drectangle) -> float\n'
        return 1.0
    
    def intersect(self: dlib.drectangle, rectangle: dlib.drectangle):
        'intersect(self: dlib.drectangle, rectangle: dlib.drectangle) -> dlib.drectangle\n'
        pass
    
    def is_empty(self: dlib.drectangle):
        'is_empty(self: dlib.drectangle) -> bool\n'
        return True
    
    def left(self: dlib.drectangle):
        'left(self: dlib.drectangle) -> float\n'
        return 1.0
    
    def right(self: dlib.drectangle):
        'right(self: dlib.drectangle) -> float\n'
        return 1.0
    
    def top(self: dlib.drectangle):
        'top(self: dlib.drectangle) -> float\n'
        return 1.0
    
    def width(self: dlib.drectangle):
        'width(self: dlib.drectangle) -> float\n'
        return 1.0
    

class face_recognition_model_v1(_mod_pybind11_builtins.pybind11_object):
    'This object maps human faces into 128D vectors where pictures of the same person are mapped near to each other and pictures of different people are mapped far apart.  The constructor loads the face recognition model from a file. The model file is available here: http://dlib.net/files/dlib_face_recognition_resnet_model_v1.dat.bz2'
    __class__ = face_recognition_model_v1
    def __init__(self: dlib.face_recognition_model_v1, arg0: str):
        '__init__(self: dlib.face_recognition_model_v1, arg0: str) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def compute_face_descriptor(self, *args, **kwargs):
        'compute_face_descriptor(*args, **kwargs)\nOverloaded function.\n\n1. compute_face_descriptor(self: dlib.face_recognition_model_v1, img: object, face: dlib.full_object_detection, num_jitters: int=0) -> dlib.vector\n\nTakes an image and a full_object_detection that references a face in that image and converts it into a 128D face descriptor. If num_jitters>1 then each face will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor.\n\n2. compute_face_descriptor(self: dlib.face_recognition_model_v1, img: object, faces: std::vector<dlib::full_object_detection, std::allocator<dlib::full_object_detection> >, num_jitters: int=0) -> dlib.vectors\n\nTakes an image and an array of full_object_detections that reference faces in that image and converts them into 128D face descriptors.  If num_jitters>1 then each face will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor.\n'
        pass
    

class fhog_object_detector(_mod_pybind11_builtins.pybind11_object):
    'This object represents a sliding window histogram-of-oriented-gradients based object detector.'
    def __call__(self: dlib.fhog_object_detector, image: object, upsample_num_times: int=0):
        '__call__(self: dlib.fhog_object_detector, image: object, upsample_num_times: int=0) -> dlib.rectangles\n\nrequires \n    - image is a numpy ndarray containing either an 8bit grayscale or RGB \n      image. \n    - upsample_num_times >= 0 \nensures \n    - This function runs the object detector on the input image and returns \n      a list of detections.   \n    - Upsamples the image upsample_num_times before running the basic \n      detector.\n'
        pass
    
    __class__ = fhog_object_detector
    def __getstate__(self: dlib.fhog_object_detector):
        '__getstate__(self: dlib.fhog_object_detector) -> tuple\n'
        pass
    
    def __init__(self: dlib.fhog_object_detector, arg0: str):
        '__init__(self: dlib.fhog_object_detector, arg0: str) -> None\n\nLoads an object detector from a file that contains the output of the \ntrain_simple_object_detector() routine or a serialized C++ object of type\nobject_detector<scan_fhog_pyramid<pyramid_down<6>>>.\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.fhog_object_detector, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def run(self: dlib.fhog_object_detector, image: object, upsample_num_times: int=0, adjust_threshold: float=0.0):
        'run(self: dlib.fhog_object_detector, image: object, upsample_num_times: int=0, adjust_threshold: float=0.0) -> tuple\n\nrequires \n    - image is a numpy ndarray containing either an 8bit grayscale or RGB \n      image. \n    - upsample_num_times >= 0 \nensures \n    - This function runs the object detector on the input image and returns \n      a tuple of (list of detections, list of scores, list of weight_indices).   \n    - Upsamples the image upsample_num_times before running the basic \n      detector.\n'
        pass
    
    @classmethod
    def run_multiple(cls, detectors: list, image: object, upsample_num_times: int=0, adjust_threshold: float=0.0):
        'run_multiple(detectors: list, image: object, upsample_num_times: int=0, adjust_threshold: float=0.0) -> tuple\n\nrequires \n    - detectors is a list of detectors. \n    - image is a numpy ndarray containing either an 8bit grayscale or RGB \n      image. \n    - upsample_num_times >= 0 \nensures \n    - This function runs the list of object detectors at once on the input image and returns \n      a tuple of (list of detections, list of scores, list of weight_indices).   \n    - Upsamples the image upsample_num_times before running the basic \n      detector.\n'
        pass
    
    def save(self: dlib.fhog_object_detector, detector_output_filename: str):
        'save(self: dlib.fhog_object_detector, detector_output_filename: str) -> None\n\nSave a simple_object_detector to the provided path.\n'
        pass
    

def find_candidate_object_locations(image: object, rects: list, kvals: tuple=(50,200,3), min_size: int=20, max_merging_iterations: int=50):
    'find_candidate_object_locations(image: object, rects: list, kvals: tuple=(50, 200, 3), min_size: int=20, max_merging_iterations: int=50) -> None\n\nReturns found candidate objects\nrequires\n    - image == an image object which is a numpy ndarray\n    - len(kvals) == 3\n    - kvals should be a tuple that specifies the range of k values to use.  In\n      particular, it should take the form (start, end, num) where num > 0. \nensures\n    - This function takes an input image and generates a set of candidate\n      rectangles which are expected to bound any objects in the image.  It does\n      this by running a version of the segment_image() routine on the image and\n      then reports rectangles containing each of the segments as well as rectangles\n      containing unions of adjacent segments.  The basic idea is described in the\n      paper: \n          Segmentation as Selective Search for Object Recognition by Koen E. A. van de Sande, et al.\n      Note that this function deviates from what is described in the paper slightly. \n      See the code for details.\n    - The basic segmentation is performed kvals[2] times, each time with the k parameter\n      (see segment_image() and the Felzenszwalb paper for details on k) set to a different\n      value from the range of numbers linearly spaced between kvals[0] to kvals[1].\n    - When doing the basic segmentations prior to any box merging, we discard all\n      rectangles that have an area < min_size.  Therefore, all outputs and\n      subsequent merged rectangles are built out of rectangles that contain at\n      least min_size pixels.  Note that setting min_size to a smaller value than\n      you might otherwise be interested in using can be useful since it allows a\n      larger number of possible merged boxes to be created.\n    - There are max_merging_iterations rounds of neighboring blob merging.\n      Therefore, this parameter has some effect on the number of output rectangles\n      you get, with larger values of the parameter giving more output rectangles.\n    - This function appends the output rectangles into #rects.  This means that any\n      rectangles in rects before this function was called will still be in there\n      after it terminates.  Note further that #rects will not contain any duplicate\n      rectangles.  That is, for all valid i and j where i != j it will be true\n      that:\n        - #rects[i] != rects[j]\n'
    pass

def find_max_global(*args, **kwargs):
    "find_max_global(*args, **kwargs)\nOverloaded function.\n\n1. find_max_global(f: object, bound1: list, bound2: list, is_integer_variable: list, num_function_calls: int, solver_epsilon: float=0) -> tuple\n\nrequires \n    - len(bound1) == len(bound2) == len(is_integer_variable) \n    - for all valid i: bound1[i] != bound2[i] \n    - solver_epsilon >= 0 \n    - f() is a real valued multi-variate function.  It must take scalar real \n      numbers as its arguments and the number of arguments must be len(bound1). \nensures \n    - This function performs global optimization on the given f() function. \n      The goal is to maximize the following objective function: \n         f(x) \n      subject to the constraints: \n        min(bound1[i],bound2[i]) <= x[i] <= max(bound1[i],bound2[i]) \n        if (is_integer_variable[i]) then x[i] is an integer. \n    - find_max_global() runs until it has called f() num_function_calls times. \n      Then it returns the best x it has found along with the corresponding output \n      of f().  That is, it returns (best_x_seen,f(best_x_seen)).  Here best_x_seen \n      is a list containing the best arguments to f() this function has found. \n    - find_max_global() uses a global optimization method based on a combination of \n      non-parametric global function modeling and quadratic trust region modeling \n      to efficiently find a global maximizer.  It usually does a good job with a \n      relatively small number of calls to f().  For more information on how it \n      works read the documentation for dlib's global_function_search object. \n      However, one notable element is the solver epsilon, which you can adjust. \n \n      The search procedure will only attempt to find a global maximizer to at most \n      solver_epsilon accuracy.  Once a local maximizer is found to that accuracy \n      the search will focus entirely on finding other maxima elsewhere rather than \n      on further improving the current local optima found so far.  That is, once a \n      local maxima is identified to about solver_epsilon accuracy, the algorithm \n      will spend all its time exploring the function to find other local maxima to \n      investigate.  An epsilon of 0 means it will keep solving until it reaches \n      full floating point precision.  Larger values will cause it to switch to pure \n      global exploration sooner and therefore might be more effective if your \n      objective function has many local maxima and you don't care about a super \n      high precision solution. \n    - Any variables that satisfy the following conditions are optimized on a log-scale: \n        - The lower bound on the variable is > 0 \n        - The ratio of the upper bound to lower bound is > 1000 \n        - The variable is not an integer variable \n      We do this because it's common to optimize machine learning models that have \n      parameters with bounds in a range such as [1e-5 to 1e10] (e.g. the SVM C \n      parameter) and it's much more appropriate to optimize these kinds of \n      variables on a log scale.  So we transform them by applying log() to \n      them and then undo the transform via exp() before invoking the function \n      being optimized.  Therefore, this transformation is invisible to the user \n      supplied functions.  In most cases, it improves the efficiency of the \n      optimizer.\n\n2. find_max_global(f: object, bound1: list, bound2: list, num_function_calls: int, solver_epsilon: float=0) -> tuple\n\nThis function simply calls the other version of find_max_global() with is_integer_variable set to False for all variables.\n"
    pass

def find_min_global(*args, **kwargs):
    'find_min_global(*args, **kwargs)\nOverloaded function.\n\n1. find_min_global(f: object, bound1: list, bound2: list, is_integer_variable: list, num_function_calls: int, solver_epsilon: float=0) -> tuple\n\nThis function is just like find_max_global(), except it performs minimization rather than maximization.\n\n2. find_min_global(f: object, bound1: list, bound2: list, num_function_calls: int, solver_epsilon: float=0) -> tuple\n\nThis function simply calls the other version of find_min_global() with is_integer_variable set to False for all variables.\n'
    pass

def find_optimal_rect_filter(rects, std, smoothness: float=1):
    'find_optimal_rect_filter(rects: std::vector<dlib::rectangle, std::allocator<dlib::rectangle> >, smoothness: float=1) -> dlib.rect_filter\n\nrequires \n    - rects.size() > 4 \n    - smoothness >= 0 \nensures \n    - This function finds the "optimal" settings of a rect_filter based on recorded \n      measurement data stored in rects.  Here we assume that rects is a complete \n      track history of some object\'s measured positions.  Essentially, what we do \n      is find the rect_filter that minimizes the following objective function: \n         sum of abs(predicted_location[i] - measured_location[i]) + smoothness*abs(filtered_location[i]-filtered_location[i-1]) \n         Where i is a time index. \n      The sum runs over all the data in rects.  So what we do is find the \n      filter settings that produce smooth filtered trajectories but also produce \n      filtered outputs that are as close to the measured positions as possible. \n      The larger the value of smoothness the less jittery the filter outputs will \n      be, but they might become biased or laggy if smoothness is set really high. \n'
    pass

class full_object_detection(_mod_pybind11_builtins.pybind11_object):
    'This object represents the location of an object in an image along with the     positions of each of its constituent parts.'
    __class__ = full_object_detection
    def __getstate__(self: dlib.full_object_detection):
        '__getstate__(self: dlib.full_object_detection) -> tuple\n'
        pass
    
    def __init__(self: dlib.full_object_detection, arg0: object, arg1: object):
        '__init__(self: dlib.full_object_detection, arg0: object, arg1: object) -> None\n\nrequires \n    - rect: dlib rectangle \n    - parts: list of dlib points\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.full_object_detection, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    num_parts = _mod_builtins.property()
    def part(self: dlib.full_object_detection, idx: int):
        'part(self: dlib.full_object_detection, idx: int) -> dlib.point\n\nA single part of the object as a dlib point.\n'
        pass
    
    def parts(self: dlib.full_object_detection):
        'parts(self: dlib.full_object_detection) -> dlib.points\n\nA vector of dlib points representing all of the parts.\n'
        pass
    
    rect = _mod_builtins.property()

class full_object_detections(_mod_pybind11_builtins.pybind11_object):
    'An array of full_object_detection objects.'
    def __bool__(self: dlib.full_object_detections):
        '__bool__(self: dlib.full_object_detections) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = full_object_detections
    def __contains__(self, value):
        '__contains__(self: dlib.full_object_detections, x: dlib.full_object_detection) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.full_object_detections, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.full_object_detections, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.full_object_detections, arg0: dlib.full_object_detections):
        '__eq__(self: dlib.full_object_detections, arg0: dlib.full_object_detections) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.full_object_detections, s: slice) -> dlib.full_object_detections\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.full_object_detections, arg0: int) -> dlib.full_object_detection\n'
        pass
    
    def __getstate__(self: dlib.full_object_detections):
        '__getstate__(self: dlib.full_object_detections) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.full_object_detections) -> None\n\n2. __init__(self: dlib.full_object_detections, arg0: dlib.full_object_detections) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.full_object_detections, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.full_object_detections):
        '__iter__(self: dlib.full_object_detections) -> iterator\n'
        return full_object_detections()
    
    def __len__(self: dlib.full_object_detections):
        '__len__(self: dlib.full_object_detections) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.full_object_detections, arg0: dlib.full_object_detections):
        '__ne__(self: dlib.full_object_detections, arg0: dlib.full_object_detections) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.full_object_detections, arg0: int, arg1: dlib.full_object_detection) -> None\n\n2. __setitem__(self: dlib.full_object_detections, arg0: slice, arg1: dlib.full_object_detections) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.full_object_detections, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.full_object_detections, x: dlib.full_object_detection):
        'append(self: dlib.full_object_detections, x: dlib.full_object_detection) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.full_object_detections):
        'clear(self: dlib.full_object_detections) -> None\n'
        pass
    
    def count(self: dlib.full_object_detections, x: dlib.full_object_detection):
        'count(self: dlib.full_object_detections, x: dlib.full_object_detection) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.full_object_detections, L: dlib.full_object_detections) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.full_object_detections, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.full_object_detections, i: int, x: dlib.full_object_detection):
        'insert(self: dlib.full_object_detections, i: int, x: dlib.full_object_detection) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.full_object_detections) -> dlib.full_object_detection\n\nRemove and return the last item\n\n2. pop(self: dlib.full_object_detections, i: int) -> dlib.full_object_detection\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.full_object_detections, x: dlib.full_object_detection):
        'remove(self: dlib.full_object_detections, x: dlib.full_object_detection) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.full_object_detections, arg0: int):
        'resize(self: dlib.full_object_detections, arg0: int) -> None\n'
        pass
    

class function_evaluation(_mod_pybind11_builtins.pybind11_object):
    '  \nThis object records the output of a real valued function in response to\nsome input. \n\nIn particular, if you have a function F(x) then the function_evaluation is\nsimply a struct that records x and the scalar value F(x). '
    __class__ = function_evaluation
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.function_evaluation, x: dlib.vector, y: float) -> None\n\n2. __init__(self: dlib.function_evaluation, x: list, y: float) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    x = _mod_builtins.property()
    y = _mod_builtins.property()

class function_evaluation_request(_mod_pybind11_builtins.pybind11_object):
    'See: http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html'
    __class__ = function_evaluation_request
    def __init__(self, *args, **kwargs):
        'See: http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    function_idx = _mod_builtins.property()
    has_been_evaluated = _mod_builtins.property()
    def set(self: dlib.function_evaluation_request, arg0: float):
        'set(self: dlib.function_evaluation_request, arg0: float) -> None\n'
        pass
    
    x = _mod_builtins.property()

class function_spec(_mod_pybind11_builtins.pybind11_object):
    'See: http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html'
    __class__ = function_spec
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.function_spec, bound1: dlib.vector, bound2: dlib.vector) -> None\n\n2. __init__(self: dlib.function_spec, bound1: dlib.vector, bound2: dlib.vector, is_integer: List[bool]) -> None\n\n3. __init__(self: dlib.function_spec, bound1: list, bound2: list) -> None\n\n4. __init__(self: dlib.function_spec, bound1: list, bound2: list, is_integer: list) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    is_integer_variable = _mod_builtins.property()
    lower = _mod_builtins.property()
    upper = _mod_builtins.property()

def get_face_chip(img: object, face: dlib.full_object_detection, size: int=150, padding: float=0.25):
    'get_face_chip(img: object, face: dlib.full_object_detection, size: int=150, padding: float=0.25) -> object\n\nTakes an image and a full_object_detection that references a face in that image and returns the face as a Numpy array representing the image.  The face will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.\n'
    pass

def get_face_chips(img: object, faces: dlib.full_object_detections, size: int=150, padding: float=0.25):
    'get_face_chips(img: object, faces: dlib.full_object_detections, size: int=150, padding: float=0.25) -> list\n\nTakes an image and a full_object_detections object that reference faces in that image and returns the faces as a list of Numpy arrays representing the image.  The faces will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.\n'
    return list()

def get_frontal_face_detector():
    'get_frontal_face_detector() -> dlib::object_detector<dlib::scan_fhog_pyramid<dlib::pyramid_down<6u>, dlib::default_fhog_feature_extractor> >\n\nReturns the default face detector\n'
    pass

class global_function_search(_mod_pybind11_builtins.pybind11_object):
    'See: http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html'
    __class__ = global_function_search
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.global_function_search, function: dlib.function_spec) -> None\n\n2. __init__(self: dlib.global_function_search, functions: list) -> None\n\n3. __init__(self: dlib.global_function_search, functions: list, initial_function_evals: list, relative_noise_magnitude: float) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def get_best_function_eval(self: dlib.global_function_search):
        'get_best_function_eval(self: dlib.global_function_search) -> tuple\n'
        pass
    
    def get_function_evaluations(self: dlib.global_function_search):
        'get_function_evaluations(self: dlib.global_function_search) -> tuple\n'
        pass
    
    def get_monte_carlo_upper_bound_sample_num(self: dlib.global_function_search):
        'get_monte_carlo_upper_bound_sample_num(self: dlib.global_function_search) -> int\n'
        return 1
    
    def get_next_x(self: dlib.global_function_search):
        'get_next_x(self: dlib.global_function_search) -> dlib.function_evaluation_request\n'
        pass
    
    def get_pure_random_search_probability(self: dlib.global_function_search):
        'get_pure_random_search_probability(self: dlib.global_function_search) -> float\n'
        return 1.0
    
    def get_relative_noise_magnitude(self: dlib.global_function_search):
        'get_relative_noise_magnitude(self: dlib.global_function_search) -> float\n'
        return 1.0
    
    def get_solver_epsilon(self: dlib.global_function_search):
        'get_solver_epsilon(self: dlib.global_function_search) -> float\n'
        return 1.0
    
    def num_functions(self: dlib.global_function_search):
        'num_functions(self: dlib.global_function_search) -> int\n'
        return 1
    
    def set_monte_carlo_upper_bound_sample_num(self: dlib.global_function_search, num: int):
        'set_monte_carlo_upper_bound_sample_num(self: dlib.global_function_search, num: int) -> None\n'
        pass
    
    def set_pure_random_search_probability(self: dlib.global_function_search, prob: float):
        'set_pure_random_search_probability(self: dlib.global_function_search, prob: float) -> None\n'
        pass
    
    def set_relative_noise_magnitude(self: dlib.global_function_search, value: float):
        'set_relative_noise_magnitude(self: dlib.global_function_search, value: float) -> None\n'
        pass
    
    def set_seed(self: dlib.global_function_search, seed: int):
        'set_seed(self: dlib.global_function_search, seed: int) -> None\n'
        pass
    
    def set_solver_epsilon(self: dlib.global_function_search, eps: float):
        'set_solver_epsilon(self: dlib.global_function_search, eps: float) -> None\n'
        pass
    

def hit_enter_to_continue():
    'hit_enter_to_continue() -> None\n\nAsks the user to hit enter to continue and pauses until they do so.\n'
    pass

def jitter_image(img: object, num_jitters: int=1, disturb_colors: bool=False):
    'jitter_image(img: object, num_jitters: int=1, disturb_colors: bool=False) -> list\n\nTakes an image and returns a list of jittered images.The returned list contains num_jitters images (default is 1).If disturb_colors is set to True, the colors of the image are disturbed (default is False)\n'
    return list()

def load_libsvm_formatted_data(file_name: str):
    'load_libsvm_formatted_data(file_name: str) -> tuple\n\nensures    \n    - Attempts to read a file of the given name that should contain libsvm    \n      formatted data.  The data is returned as a tuple where the first tuple    \n      element is an array of sparse vectors and the second element is an array of    \n      labels.    \n'
    pass

def make_bounding_box_regression_training_data(truth: dlib.image_dataset_metadata.dataset, detections: object):
    "make_bounding_box_regression_training_data(truth: dlib.image_dataset_metadata.dataset, detections: object) -> dlib.image_dataset_metadata.dataset\n\nrequires \n    - len(truth.images) == len(detections) \n    - detections == A dlib.rectangless object or a list of dlib.rectangles. \nensures \n    - Suppose you have an object detector that can roughly locate objects in an \n      image.  This means your detector draws boxes around objects, but these are \n      *rough* boxes in the sense that they aren't positioned super accurately.  For \n      instance, HOG based detectors usually have a stride of 8 pixels.  So the \n      positional accuracy is going to be, at best, +/-8 pixels.   \n       \n      If you want to get better positional accuracy one easy thing to do is train a \n      shape_predictor to give you the corners of the object.  The \n      make_bounding_box_regression_training_data() routine helps you do this by \n      creating an appropriate training dataset.  It does this by taking the dataset \n      you used to train your detector (the truth object), and combining that with \n      the output of your detector on each image in the training dataset (the \n      detections object).  In particular, it will create a new annotated dataset \n      where each object box is one of the rectangles from detections and that \n      object has 4 part annotations, the corners of the truth rectangle \n      corresponding to that detection rectangle.  You can then take the returned \n      dataset and train a shape_predictor on it.  The resulting shape_predictor can \n      then be used to do bounding box regression. \n    - We assume that detections[i] contains object detections corresponding to  \n      the image truth.images[i].\n"
    pass

def make_sparse_vector(*args, **kwargs):
    "make_sparse_vector(*args, **kwargs)\nOverloaded function.\n\n1. make_sparse_vector(arg0: dlib.sparse_vector) -> None\n\nThis function modifies its argument so that it is a properly sorted sparse vector.    \nThis means that the elements of the sparse vector will be ordered so that pairs    \nwith smaller indices come first.  Additionally, there won't be any pairs with    \nidentical indices.  If such pairs were present in the input sparse vector then    \ntheir values will be added together and only one pair with their index will be    \npresent in the output.   \n\n2. make_sparse_vector(arg0: dlib.sparse_vectors) -> None\n\nThis function modifies a sparse_vectors object so that all elements it contains are properly sorted sparse vectors.\n"
    pass

class matrix(_mod_pybind11_builtins.pybind11_object):
    'This object represents a dense 2D matrix of floating point numbers.Moreover, it binds directly to the C++ type dlib::matrix<double>.'
    __class__ = matrix
    def __getitem__(self, index):
        '__getitem__(self: dlib.matrix, arg0: int) -> dlib._row\n'
        pass
    
    def __getstate__(self: dlib.matrix):
        '__getstate__(self: dlib.matrix) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.matrix) -> None\n\n2. __init__(self: dlib.matrix, arg0: list) -> None\n\n3. __init__(self: dlib.matrix, arg0: object) -> None\n\n4. __init__(self: dlib.matrix, arg0: int, arg1: int) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __len__(self: dlib.matrix):
        '__len__(self: dlib.matrix) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __repr__(self: dlib.matrix):
        '__repr__(self: dlib.matrix) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.matrix, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.matrix):
        '__str__(self: dlib.matrix) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def nc(self: dlib.matrix):
        'nc(self: dlib.matrix) -> int\n\nReturn the number of columns in the matrix.\n'
        return 1
    
    def nr(self: dlib.matrix):
        'nr(self: dlib.matrix) -> int\n\nReturn the number of rows in the matrix.\n'
        return 1
    
    def set_size(self: dlib.matrix, rows: int, cols: int):
        'set_size(self: dlib.matrix, rows: int, cols: int) -> None\n\nSet the size of the matrix to the given number of rows and columns.\n'
        pass
    
    shape = _mod_builtins.property()

def max_cost_assignment(cost: dlib.matrix):
    "max_cost_assignment(cost: dlib.matrix) -> list\n\nrequires    \n    - cost.nr() == cost.nc()    \n      (i.e. the input must be a square matrix)    \nensures    \n    - Finds and returns the solution to the following optimization problem:    \n    \n        Maximize: f(A) == assignment_cost(cost, A)    \n        Subject to the following constraints:    \n            - The elements of A are unique. That is, there aren't any     \n              elements of A which are equal.      \n            - len(A) == cost.nr()    \n    \n    - Note that this function converts the input cost matrix into a 64bit fixed    \n      point representation.  Therefore, you should make sure that the values in    \n      your cost matrix can be accurately represented by 64bit fixed point values.    \n      If this is not the case then the solution my become inaccurate due to    \n      rounding error.  In general, this function will work properly when the ratio    \n      of the largest to the smallest value in cost is no more than about 1e16.   \n"
    return list()

def max_index_plus_one(v: dlib.sparse_vector):
    'max_index_plus_one(v: dlib.sparse_vector) -> int\n\nensures    \n    - returns the dimensionality of the given sparse vector.  That is, returns a    \n      number one larger than the maximum index value in the vector.  If the vector    \n      is empty then returns 0.   \n'
    return 1

class mmod_rectangle(_mod_pybind11_builtins.pybind11_object):
    'Wrapper around a rectangle object and a detection confidence score.'
    __class__ = mmod_rectangle
    def __init__(self, *args, **kwargs):
        'Wrapper around a rectangle object and a detection confidence score.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    confidence = _mod_builtins.property()
    rect = _mod_builtins.property()

class mmod_rectangles(_mod_pybind11_builtins.pybind11_object):
    'An array of mmod rectangle objects.'
    def __bool__(self: dlib.mmod_rectangles):
        '__bool__(self: dlib.mmod_rectangles) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = mmod_rectangles
    def __contains__(self, value):
        '__contains__(self: dlib.mmod_rectangles, x: dlib.mmod_rectangle) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.mmod_rectangles, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.mmod_rectangles, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.mmod_rectangles, arg0: dlib.mmod_rectangles):
        '__eq__(self: dlib.mmod_rectangles, arg0: dlib.mmod_rectangles) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.mmod_rectangles, s: slice) -> dlib.mmod_rectangles\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.mmod_rectangles, arg0: int) -> dlib.mmod_rectangle\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.mmod_rectangles) -> None\n\n2. __init__(self: dlib.mmod_rectangles, arg0: dlib.mmod_rectangles) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.mmod_rectangles, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.mmod_rectangles):
        '__iter__(self: dlib.mmod_rectangles) -> iterator\n'
        return mmod_rectangles()
    
    def __len__(self: dlib.mmod_rectangles):
        '__len__(self: dlib.mmod_rectangles) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.mmod_rectangles, arg0: dlib.mmod_rectangles):
        '__ne__(self: dlib.mmod_rectangles, arg0: dlib.mmod_rectangles) -> bool\n'
        return False
    
    def __repr__(self: dlib.mmod_rectangles):
        '__repr__(self: dlib.mmod_rectangles) -> str\n\nReturn the canonical string representation of this list.\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.mmod_rectangles, arg0: int, arg1: dlib.mmod_rectangle) -> None\n\n2. __setitem__(self: dlib.mmod_rectangles, arg0: slice, arg1: dlib.mmod_rectangles) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.mmod_rectangles, x: dlib.mmod_rectangle):
        'append(self: dlib.mmod_rectangles, x: dlib.mmod_rectangle) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def count(self: dlib.mmod_rectangles, x: dlib.mmod_rectangle):
        'count(self: dlib.mmod_rectangles, x: dlib.mmod_rectangle) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.mmod_rectangles, L: dlib.mmod_rectangles) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.mmod_rectangles, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.mmod_rectangles, i: int, x: dlib.mmod_rectangle):
        'insert(self: dlib.mmod_rectangles, i: int, x: dlib.mmod_rectangle) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.mmod_rectangles) -> dlib.mmod_rectangle\n\nRemove and return the last item\n\n2. pop(self: dlib.mmod_rectangles, i: int) -> dlib.mmod_rectangle\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.mmod_rectangles, x: dlib.mmod_rectangle):
        'remove(self: dlib.mmod_rectangles, x: dlib.mmod_rectangle) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    

class mmod_rectangless(_mod_pybind11_builtins.pybind11_object):
    'A 2D array of mmod rectangle objects.'
    def __bool__(self: dlib.mmod_rectangless):
        '__bool__(self: dlib.mmod_rectangless) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = mmod_rectangless
    def __contains__(self, value):
        '__contains__(self: dlib.mmod_rectangless, x: dlib.mmod_rectangles) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.mmod_rectangless, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.mmod_rectangless, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.mmod_rectangless, arg0: dlib.mmod_rectangless):
        '__eq__(self: dlib.mmod_rectangless, arg0: dlib.mmod_rectangless) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.mmod_rectangless, s: slice) -> dlib.mmod_rectangless\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.mmod_rectangless, arg0: int) -> dlib.mmod_rectangles\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.mmod_rectangless) -> None\n\n2. __init__(self: dlib.mmod_rectangless, arg0: dlib.mmod_rectangless) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.mmod_rectangless, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.mmod_rectangless):
        '__iter__(self: dlib.mmod_rectangless) -> iterator\n'
        return mmod_rectangless()
    
    def __len__(self: dlib.mmod_rectangless):
        '__len__(self: dlib.mmod_rectangless) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.mmod_rectangless, arg0: dlib.mmod_rectangless):
        '__ne__(self: dlib.mmod_rectangless, arg0: dlib.mmod_rectangless) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.mmod_rectangless, arg0: int, arg1: dlib.mmod_rectangles) -> None\n\n2. __setitem__(self: dlib.mmod_rectangless, arg0: slice, arg1: dlib.mmod_rectangless) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.mmod_rectangless, x: dlib.mmod_rectangles):
        'append(self: dlib.mmod_rectangless, x: dlib.mmod_rectangles) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def count(self: dlib.mmod_rectangless, x: dlib.mmod_rectangles):
        'count(self: dlib.mmod_rectangless, x: dlib.mmod_rectangles) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.mmod_rectangless, L: dlib.mmod_rectangless) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.mmod_rectangless, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.mmod_rectangless, i: int, x: dlib.mmod_rectangles):
        'insert(self: dlib.mmod_rectangless, i: int, x: dlib.mmod_rectangles) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.mmod_rectangless) -> dlib.mmod_rectangles\n\nRemove and return the last item\n\n2. pop(self: dlib.mmod_rectangless, i: int) -> dlib.mmod_rectangles\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.mmod_rectangless, x: dlib.mmod_rectangles):
        'remove(self: dlib.mmod_rectangless, x: dlib.mmod_rectangles) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    

class pair(_mod_pybind11_builtins.pybind11_object):
    'This object is used to represent the elements of a sparse_vector.'
    __class__ = pair
    def __getstate__(self: dlib.pair):
        '__getstate__(self: dlib.pair) -> tuple\n'
        pass
    
    def __init__(self: dlib.pair, arg0: int, arg1: float):
        '__init__(self: dlib.pair, arg0: int, arg1: float) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib.pair):
        '__repr__(self: dlib.pair) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.pair, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.pair):
        '__str__(self: dlib.pair) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    first = _mod_builtins.property()
    second = _mod_builtins.property()

class point(_mod_pybind11_builtins.pybind11_object):
    'This object represents a single point of integer coordinates that maps directly to a dlib::point.'
    __class__ = point
    def __getstate__(self: dlib.point):
        '__getstate__(self: dlib.point) -> tuple\n'
        pass
    
    def __init__(self: dlib.point, x: int, y: int):
        '__init__(self: dlib.point, x: int, y: int) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib.point):
        '__repr__(self: dlib.point) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.point, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.point):
        '__str__(self: dlib.point) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    x = _mod_builtins.property()
    y = _mod_builtins.property()

class points(_mod_pybind11_builtins.pybind11_object):
    'An array of point objects.'
    def __bool__(self: dlib.points):
        '__bool__(self: dlib.points) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = points
    def __contains__(self, value):
        '__contains__(self: dlib.points, x: dlib.point) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.points, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.points, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.points, arg0: dlib.points):
        '__eq__(self: dlib.points, arg0: dlib.points) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.points, s: slice) -> dlib.points\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.points, arg0: int) -> dlib.point\n'
        pass
    
    def __getstate__(self: dlib.points):
        '__getstate__(self: dlib.points) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.points) -> None\n\n2. __init__(self: dlib.points, arg0: dlib.points) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.points, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.points):
        '__iter__(self: dlib.points) -> iterator\n'
        return points()
    
    def __len__(self: dlib.points):
        '__len__(self: dlib.points) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.points, arg0: dlib.points):
        '__ne__(self: dlib.points, arg0: dlib.points) -> bool\n'
        return False
    
    def __repr__(self: dlib.points):
        '__repr__(self: dlib.points) -> str\n\nReturn the canonical string representation of this list.\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.points, arg0: int, arg1: dlib.point) -> None\n\n2. __setitem__(self: dlib.points, arg0: slice, arg1: dlib.points) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.points, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.points, x: dlib.point):
        'append(self: dlib.points, x: dlib.point) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.points):
        'clear(self: dlib.points) -> None\n'
        pass
    
    def count(self: dlib.points, x: dlib.point):
        'count(self: dlib.points, x: dlib.point) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.points, L: dlib.points) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.points, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.points, i: int, x: dlib.point):
        'insert(self: dlib.points, i: int, x: dlib.point) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.points) -> dlib.point\n\nRemove and return the last item\n\n2. pop(self: dlib.points, i: int) -> dlib.point\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.points, x: dlib.point):
        'remove(self: dlib.points, x: dlib.point) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.points, arg0: int):
        'resize(self: dlib.points, arg0: int) -> None\n'
        pass
    

def probability_that_sequence_is_increasing(time_series: object):
    'probability_that_sequence_is_increasing(time_series: object) -> float\n\nreturns the probability that the given sequence of real numbers is increasing in value over time.\n'
    return 1.0

class range(_mod_pybind11_builtins.pybind11_object):
    'This object is used to represent a range of elements in an array.'
    __class__ = range
    def __getstate__(self: dlib.range):
        '__getstate__(self: dlib.range) -> tuple\n'
        pass
    
    def __init__(self: dlib.range, arg0: int, arg1: int):
        '__init__(self: dlib.range, arg0: int, arg1: int) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.range):
        '__iter__(self: dlib.range) -> range_iter\n'
        return range()
    
    def __len__(self: dlib.range):
        '__len__(self: dlib.range) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __repr__(self: dlib.range):
        '__repr__(self: dlib.range) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.range, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.range):
        '__str__(self: dlib.range) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    begin = _mod_builtins.property()
    end = _mod_builtins.property()

class ranges(_mod_pybind11_builtins.pybind11_object):
    'This object is an array of range objects.'
    def __bool__(self: dlib.ranges):
        '__bool__(self: dlib.ranges) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = ranges
    def __contains__(self, value):
        '__contains__(self: dlib.ranges, x: dlib.range) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.ranges, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.ranges, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.ranges, arg0: dlib.ranges):
        '__eq__(self: dlib.ranges, arg0: dlib.ranges) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.ranges, s: slice) -> dlib.ranges\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.ranges, arg0: int) -> dlib.range\n'
        pass
    
    def __getstate__(self: dlib.ranges):
        '__getstate__(self: dlib.ranges) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.ranges) -> None\n\n2. __init__(self: dlib.ranges, arg0: dlib.ranges) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.ranges, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.ranges):
        '__iter__(self: dlib.ranges) -> iterator\n'
        return ranges()
    
    def __len__(self: dlib.ranges):
        '__len__(self: dlib.ranges) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.ranges, arg0: dlib.ranges):
        '__ne__(self: dlib.ranges, arg0: dlib.ranges) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.ranges, arg0: int, arg1: dlib.range) -> None\n\n2. __setitem__(self: dlib.ranges, arg0: slice, arg1: dlib.ranges) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.ranges, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.ranges, x: dlib.range):
        'append(self: dlib.ranges, x: dlib.range) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.ranges):
        'clear(self: dlib.ranges) -> None\n'
        pass
    
    def count(self: dlib.ranges, x: dlib.range):
        'count(self: dlib.ranges, x: dlib.range) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.ranges, L: dlib.ranges) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.ranges, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.ranges, i: int, x: dlib.range):
        'insert(self: dlib.ranges, i: int, x: dlib.range) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.ranges) -> dlib.range\n\nRemove and return the last item\n\n2. pop(self: dlib.ranges, i: int) -> dlib.range\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.ranges, x: dlib.range):
        'remove(self: dlib.ranges, x: dlib.range) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.ranges, arg0: int):
        'resize(self: dlib.ranges, arg0: int) -> None\n'
        pass
    

class rangess(_mod_pybind11_builtins.pybind11_object):
    'This object is an array of arrays of range objects.'
    def __bool__(self: dlib.rangess):
        '__bool__(self: dlib.rangess) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = rangess
    def __contains__(self, value):
        '__contains__(self: dlib.rangess, x: dlib.ranges) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.rangess, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.rangess, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.rangess, arg0: dlib.rangess):
        '__eq__(self: dlib.rangess, arg0: dlib.rangess) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.rangess, s: slice) -> dlib.rangess\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.rangess, arg0: int) -> dlib.ranges\n'
        pass
    
    def __getstate__(self: dlib.rangess):
        '__getstate__(self: dlib.rangess) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.rangess) -> None\n\n2. __init__(self: dlib.rangess, arg0: dlib.rangess) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.rangess, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.rangess):
        '__iter__(self: dlib.rangess) -> iterator\n'
        return rangess()
    
    def __len__(self: dlib.rangess):
        '__len__(self: dlib.rangess) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.rangess, arg0: dlib.rangess):
        '__ne__(self: dlib.rangess, arg0: dlib.rangess) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.rangess, arg0: int, arg1: dlib.ranges) -> None\n\n2. __setitem__(self: dlib.rangess, arg0: slice, arg1: dlib.rangess) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.rangess, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.rangess, x: dlib.ranges):
        'append(self: dlib.rangess, x: dlib.ranges) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.rangess):
        'clear(self: dlib.rangess) -> None\n'
        pass
    
    def count(self: dlib.rangess, x: dlib.ranges):
        'count(self: dlib.rangess, x: dlib.ranges) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.rangess, L: dlib.rangess) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.rangess, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.rangess, i: int, x: dlib.ranges):
        'insert(self: dlib.rangess, i: int, x: dlib.ranges) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.rangess) -> dlib.ranges\n\nRemove and return the last item\n\n2. pop(self: dlib.rangess, i: int) -> dlib.ranges\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.rangess, x: dlib.ranges):
        'remove(self: dlib.rangess, x: dlib.ranges) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.rangess, arg0: int):
        'resize(self: dlib.rangess, arg0: int) -> None\n'
        pass
    

class ranking_pair(_mod_pybind11_builtins.pybind11_object):
    __class__ = ranking_pair
    def __getstate__(self: dlib.ranking_pair):
        '__getstate__(self: dlib.ranking_pair) -> tuple\n'
        pass
    
    def __init__(self: dlib.ranking_pair):
        '__init__(self: dlib.ranking_pair) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.ranking_pair, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    nonrelevant = _mod_builtins.property()
    relevant = _mod_builtins.property()

class ranking_pairs(_mod_pybind11_builtins.pybind11_object):
    def __bool__(self: dlib.ranking_pairs):
        '__bool__(self: dlib.ranking_pairs) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = ranking_pairs
    def __contains__(self, value):
        '__contains__(self: dlib.ranking_pairs, x: dlib.ranking_pair) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.ranking_pairs, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.ranking_pairs, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.ranking_pairs, arg0: dlib.ranking_pairs):
        '__eq__(self: dlib.ranking_pairs, arg0: dlib.ranking_pairs) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.ranking_pairs, s: slice) -> dlib.ranking_pairs\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.ranking_pairs, arg0: int) -> dlib.ranking_pair\n'
        pass
    
    def __getstate__(self: dlib.ranking_pairs):
        '__getstate__(self: dlib.ranking_pairs) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.ranking_pairs) -> None\n\n2. __init__(self: dlib.ranking_pairs, arg0: dlib.ranking_pairs) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.ranking_pairs, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.ranking_pairs):
        '__iter__(self: dlib.ranking_pairs) -> iterator\n'
        return ranking_pairs()
    
    def __len__(self: dlib.ranking_pairs):
        '__len__(self: dlib.ranking_pairs) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.ranking_pairs, arg0: dlib.ranking_pairs):
        '__ne__(self: dlib.ranking_pairs, arg0: dlib.ranking_pairs) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.ranking_pairs, arg0: int, arg1: dlib.ranking_pair) -> None\n\n2. __setitem__(self: dlib.ranking_pairs, arg0: slice, arg1: dlib.ranking_pairs) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.ranking_pairs, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.ranking_pairs, x: dlib.ranking_pair):
        'append(self: dlib.ranking_pairs, x: dlib.ranking_pair) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.ranking_pairs):
        'clear(self: dlib.ranking_pairs) -> None\n'
        pass
    
    def count(self: dlib.ranking_pairs, x: dlib.ranking_pair):
        'count(self: dlib.ranking_pairs, x: dlib.ranking_pair) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.ranking_pairs, L: dlib.ranking_pairs) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.ranking_pairs, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.ranking_pairs, i: int, x: dlib.ranking_pair):
        'insert(self: dlib.ranking_pairs, i: int, x: dlib.ranking_pair) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.ranking_pairs) -> dlib.ranking_pair\n\nRemove and return the last item\n\n2. pop(self: dlib.ranking_pairs, i: int) -> dlib.ranking_pair\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.ranking_pairs, x: dlib.ranking_pair):
        'remove(self: dlib.ranking_pairs, x: dlib.ranking_pair) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.ranking_pairs, arg0: int):
        'resize(self: dlib.ranking_pairs, arg0: int) -> None\n'
        pass
    

class rect_filter(_mod_pybind11_builtins.pybind11_object):
    ' \n                This object is a simple tool for filtering a rectangle that\n                measures the location of a moving object that has some non-trivial\n                momentum.  Importantly, the measurements are noisy and the object can\n                experience sudden unpredictable accelerations.  To accomplish this\n                filtering we use a simple Kalman filter with a state transition model of:\n\n                    position_{i+1} = position_{i} + velocity_{i} \n                    velocity_{i+1} = velocity_{i} + some_unpredictable_acceleration\n\n                and a measurement model of:\n                    \n                    measured_position_{i} = position_{i} + measurement_noise\n\n                Where some_unpredictable_acceleration and measurement_noise are 0 mean Gaussian \n                noise sources with standard deviations of typical_acceleration and\n                measurement_noise respectively.\n\n                To allow for really sudden and large but infrequent accelerations, at each\n                step we check if the current measured position deviates from the predicted\n                filtered position by more than max_measurement_deviation*measurement_noise \n                and if so we adjust the filter\'s state to keep it within these bounds.\n                This allows the moving object to undergo large unmodeled accelerations, far\n                in excess of what would be suggested by typical_acceleration, without\n                then experiencing a long lag time where the Kalman filter has to "catches\n                up" to the new position.  '
    def __call__(self: dlib.rect_filter, rect: dlib.rectangle):
        '__call__(self: dlib.rect_filter, rect: dlib.rectangle) -> dlib.rectangle\n'
        pass
    
    __class__ = rect_filter
    def __getstate__(self: dlib.rect_filter):
        '__getstate__(self: dlib.rect_filter) -> tuple\n'
        pass
    
    def __init__(self: dlib.rect_filter, measurement_noise: float, typical_acceleration: float, max_measurement_deviation: float):
        '__init__(self: dlib.rect_filter, measurement_noise: float, typical_acceleration: float, max_measurement_deviation: float) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib.rect_filter):
        '__repr__(self: dlib.rect_filter) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.rect_filter, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def max_measurement_deviation(self: dlib.rect_filter):
        'max_measurement_deviation(self: dlib.rect_filter) -> float\n'
        return 1.0
    
    def measurement_noise(self: dlib.rect_filter):
        'measurement_noise(self: dlib.rect_filter) -> float\n'
        return 1.0
    
    def typical_acceleration(self: dlib.rect_filter):
        'typical_acceleration(self: dlib.rect_filter) -> float\n'
        return 1.0
    

class rectangle(_mod_pybind11_builtins.pybind11_object):
    'This object represents a rectangular area of an image.'
    def __add__(self, *args, **kwargs):
        '__add__(*args, **kwargs)\nOverloaded function.\n\n1. __add__(self: dlib.rectangle, arg0: dlib.point) -> dlib.rectangle\n\n2. __add__(self: dlib.rectangle, arg0: dlib.rectangle) -> dlib.rectangle\n'
        return rectangle()
    
    __class__ = rectangle
    def __eq__(self: dlib.rectangle, arg0: dlib.rectangle):
        '__eq__(self: dlib.rectangle, arg0: dlib.rectangle) -> bool\n'
        return False
    
    def __getstate__(self: dlib.rectangle):
        '__getstate__(self: dlib.rectangle) -> tuple\n'
        pass
    
    def __iadd__(self, *args, **kwargs):
        '__iadd__(*args, **kwargs)\nOverloaded function.\n\n1. __iadd__(self: dlib.rectangle, arg0: dlib.point) -> dlib.rectangle\n\n2. __iadd__(self: dlib.rectangle, arg0: dlib.rectangle) -> dlib.rectangle\n'
        return None
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.rectangle, left: int, top: int, right: int, bottom: int) -> None\n\n2. __init__(self: dlib.rectangle) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __ne__(self: dlib.rectangle, arg0: dlib.rectangle):
        '__ne__(self: dlib.rectangle, arg0: dlib.rectangle) -> bool\n'
        return False
    
    def __repr__(self: dlib.rectangle):
        '__repr__(self: dlib.rectangle) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.rectangle, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.rectangle):
        '__str__(self: dlib.rectangle) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def area(self: dlib.rectangle):
        'area(self: dlib.rectangle) -> int\n'
        return 1
    
    def bottom(self: dlib.rectangle):
        'bottom(self: dlib.rectangle) -> int\n'
        return 1
    
    def center(self: dlib.rectangle):
        'center(self: dlib.rectangle) -> dlib.point\n'
        pass
    
    def contains(self, *args, **kwargs):
        'contains(*args, **kwargs)\nOverloaded function.\n\n1. contains(self: dlib.rectangle, point: dlib.point) -> bool\n\n2. contains(self: dlib.rectangle, x: int, y: int) -> bool\n\n3. contains(self: dlib.rectangle, rectangle: dlib.rectangle) -> bool\n'
        pass
    
    def dcenter(self: dlib.rectangle):
        'dcenter(self: dlib.rectangle) -> dlib.point\n'
        pass
    
    def height(self: dlib.rectangle):
        'height(self: dlib.rectangle) -> int\n'
        return 1
    
    def intersect(self: dlib.rectangle, rectangle: dlib.rectangle):
        'intersect(self: dlib.rectangle, rectangle: dlib.rectangle) -> dlib.rectangle\n'
        pass
    
    def is_empty(self: dlib.rectangle):
        'is_empty(self: dlib.rectangle) -> bool\n'
        return True
    
    def left(self: dlib.rectangle):
        'left(self: dlib.rectangle) -> int\n'
        return 1
    
    def right(self: dlib.rectangle):
        'right(self: dlib.rectangle) -> int\n'
        return 1
    
    def top(self: dlib.rectangle):
        'top(self: dlib.rectangle) -> int\n'
        return 1
    
    def width(self: dlib.rectangle):
        'width(self: dlib.rectangle) -> int\n'
        return 1
    

class rectangles(_mod_pybind11_builtins.pybind11_object):
    'An array of rectangle objects.'
    def __bool__(self: dlib.rectangles):
        '__bool__(self: dlib.rectangles) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = rectangles
    def __contains__(self, value):
        '__contains__(self: dlib.rectangles, x: dlib.rectangle) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.rectangles, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.rectangles, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.rectangles, arg0: dlib.rectangles):
        '__eq__(self: dlib.rectangles, arg0: dlib.rectangles) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.rectangles, s: slice) -> dlib.rectangles\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.rectangles, arg0: int) -> dlib.rectangle\n'
        pass
    
    def __getstate__(self: dlib.rectangles):
        '__getstate__(self: dlib.rectangles) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.rectangles) -> None\n\n2. __init__(self: dlib.rectangles, arg0: dlib.rectangles) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.rectangles, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.rectangles):
        '__iter__(self: dlib.rectangles) -> iterator\n'
        return rectangles()
    
    def __len__(self: dlib.rectangles):
        '__len__(self: dlib.rectangles) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.rectangles, arg0: dlib.rectangles):
        '__ne__(self: dlib.rectangles, arg0: dlib.rectangles) -> bool\n'
        return False
    
    def __repr__(self: dlib.rectangles):
        '__repr__(self: dlib.rectangles) -> str\n\nReturn the canonical string representation of this list.\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.rectangles, arg0: int, arg1: dlib.rectangle) -> None\n\n2. __setitem__(self: dlib.rectangles, arg0: slice, arg1: dlib.rectangles) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.rectangles, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.rectangles, x: dlib.rectangle):
        'append(self: dlib.rectangles, x: dlib.rectangle) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.rectangles):
        'clear(self: dlib.rectangles) -> None\n'
        pass
    
    def count(self: dlib.rectangles, x: dlib.rectangle):
        'count(self: dlib.rectangles, x: dlib.rectangle) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.rectangles, L: dlib.rectangles) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.rectangles, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.rectangles, i: int, x: dlib.rectangle):
        'insert(self: dlib.rectangles, i: int, x: dlib.rectangle) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.rectangles) -> dlib.rectangle\n\nRemove and return the last item\n\n2. pop(self: dlib.rectangles, i: int) -> dlib.rectangle\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.rectangles, x: dlib.rectangle):
        'remove(self: dlib.rectangles, x: dlib.rectangle) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.rectangles, arg0: int):
        'resize(self: dlib.rectangles, arg0: int) -> None\n'
        pass
    

class rectangless(_mod_pybind11_builtins.pybind11_object):
    'An array of arrays of rectangle objects.'
    def __bool__(self: dlib.rectangless):
        '__bool__(self: dlib.rectangless) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = rectangless
    def __contains__(self, value):
        '__contains__(self: dlib.rectangless, x: dlib.rectangles) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.rectangless, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.rectangless, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.rectangless, arg0: dlib.rectangless):
        '__eq__(self: dlib.rectangless, arg0: dlib.rectangless) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.rectangless, s: slice) -> dlib.rectangless\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.rectangless, arg0: int) -> dlib.rectangles\n'
        pass
    
    def __getstate__(self: dlib.rectangless):
        '__getstate__(self: dlib.rectangless) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.rectangless) -> None\n\n2. __init__(self: dlib.rectangless, arg0: dlib.rectangless) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.rectangless, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.rectangless):
        '__iter__(self: dlib.rectangless) -> iterator\n'
        return rectangless()
    
    def __len__(self: dlib.rectangless):
        '__len__(self: dlib.rectangless) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.rectangless, arg0: dlib.rectangless):
        '__ne__(self: dlib.rectangless, arg0: dlib.rectangless) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.rectangless, arg0: int, arg1: dlib.rectangles) -> None\n\n2. __setitem__(self: dlib.rectangless, arg0: slice, arg1: dlib.rectangless) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.rectangless, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.rectangless, x: dlib.rectangles):
        'append(self: dlib.rectangless, x: dlib.rectangles) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.rectangless):
        'clear(self: dlib.rectangless) -> None\n'
        pass
    
    def count(self: dlib.rectangless, x: dlib.rectangles):
        'count(self: dlib.rectangless, x: dlib.rectangles) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.rectangless, L: dlib.rectangless) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.rectangles, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.rectangless, i: int, x: dlib.rectangles):
        'insert(self: dlib.rectangless, i: int, x: dlib.rectangles) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.rectangless) -> dlib.rectangles\n\nRemove and return the last item\n\n2. pop(self: dlib.rectangless, i: int) -> dlib.rectangles\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.rectangless, x: dlib.rectangles):
        'remove(self: dlib.rectangless, x: dlib.rectangles) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.rectangless, arg0: int):
        'resize(self: dlib.rectangless, arg0: int) -> None\n'
        pass
    

class rgb_pixel(_mod_pybind11_builtins.pybind11_object):
    __class__ = rgb_pixel
    def __init__(self: dlib.rgb_pixel, red: int, green: int, blue: int):
        '__init__(self: dlib.rgb_pixel, red: int, green: int, blue: int) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib.rgb_pixel):
        '__repr__(self: dlib.rgb_pixel) -> str\n'
        return ''
    
    def __str__(self: dlib.rgb_pixel):
        '__str__(self: dlib.rgb_pixel) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    blue = _mod_builtins.property()
    green = _mod_builtins.property()
    red = _mod_builtins.property()

class rvm_trainer_histogram_intersection(_mod_pybind11_builtins.pybind11_object):
    __class__ = rvm_trainer_histogram_intersection
    def __init__(self: dlib.rvm_trainer_histogram_intersection):
        '__init__(self: dlib.rvm_trainer_histogram_intersection) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    epsilon = _mod_builtins.property()
    def train(self: dlib.rvm_trainer_histogram_intersection, arg0: dlib.vectors, arg1: dlib.array):
        'train(self: dlib.rvm_trainer_histogram_intersection, arg0: dlib.vectors, arg1: dlib.array) -> dlib._decision_function_histogram_intersection\n'
        pass
    

class rvm_trainer_linear(_mod_pybind11_builtins.pybind11_object):
    __class__ = rvm_trainer_linear
    def __init__(self: dlib.rvm_trainer_linear):
        '__init__(self: dlib.rvm_trainer_linear) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    epsilon = _mod_builtins.property()
    def train(self: dlib.rvm_trainer_linear, arg0: dlib.vectors, arg1: dlib.array):
        'train(self: dlib.rvm_trainer_linear, arg0: dlib.vectors, arg1: dlib.array) -> dlib._decision_function_linear\n'
        pass
    

class rvm_trainer_radial_basis(_mod_pybind11_builtins.pybind11_object):
    __class__ = rvm_trainer_radial_basis
    def __init__(self: dlib.rvm_trainer_radial_basis):
        '__init__(self: dlib.rvm_trainer_radial_basis) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    epsilon = _mod_builtins.property()
    gamma = _mod_builtins.property()
    def train(self: dlib.rvm_trainer_radial_basis, arg0: dlib.vectors, arg1: dlib.array):
        'train(self: dlib.rvm_trainer_radial_basis, arg0: dlib.vectors, arg1: dlib.array) -> dlib._decision_function_radial_basis\n'
        pass
    

class rvm_trainer_sparse_histogram_intersection(_mod_pybind11_builtins.pybind11_object):
    __class__ = rvm_trainer_sparse_histogram_intersection
    def __init__(self: dlib.rvm_trainer_sparse_histogram_intersection):
        '__init__(self: dlib.rvm_trainer_sparse_histogram_intersection) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    epsilon = _mod_builtins.property()
    def train(self: dlib.rvm_trainer_sparse_histogram_intersection, arg0: dlib.sparse_vectors, arg1: dlib.array):
        'train(self: dlib.rvm_trainer_sparse_histogram_intersection, arg0: dlib.sparse_vectors, arg1: dlib.array) -> dlib._decision_function_sparse_histogram_intersection\n'
        pass
    

class rvm_trainer_sparse_linear(_mod_pybind11_builtins.pybind11_object):
    __class__ = rvm_trainer_sparse_linear
    def __init__(self: dlib.rvm_trainer_sparse_linear):
        '__init__(self: dlib.rvm_trainer_sparse_linear) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    epsilon = _mod_builtins.property()
    def train(self: dlib.rvm_trainer_sparse_linear, arg0: dlib.sparse_vectors, arg1: dlib.array):
        'train(self: dlib.rvm_trainer_sparse_linear, arg0: dlib.sparse_vectors, arg1: dlib.array) -> dlib._decision_function_sparse_linear\n'
        pass
    

class rvm_trainer_sparse_radial_basis(_mod_pybind11_builtins.pybind11_object):
    __class__ = rvm_trainer_sparse_radial_basis
    def __init__(self: dlib.rvm_trainer_sparse_radial_basis):
        '__init__(self: dlib.rvm_trainer_sparse_radial_basis) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    epsilon = _mod_builtins.property()
    gamma = _mod_builtins.property()
    def train(self: dlib.rvm_trainer_sparse_radial_basis, arg0: dlib.sparse_vectors, arg1: dlib.array):
        'train(self: dlib.rvm_trainer_sparse_radial_basis, arg0: dlib.sparse_vectors, arg1: dlib.array) -> dlib._decision_function_sparse_radial_basis\n'
        pass
    

def save_face_chip(img: object, face: dlib.full_object_detection, chip_filename: str, size: int=150, padding: float=0.25):
    'save_face_chip(img: object, face: dlib.full_object_detection, chip_filename: str, size: int=150, padding: float=0.25) -> None\n\nTakes an image and a full_object_detection that references a face in that image and saves the face with the specified file name prefix.  The face will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.\n'
    pass

def save_face_chips(img: object, faces, std, chip_filename: str, size: int=150, padding: float=0.25):
    'save_face_chips(img: object, faces: std::vector<dlib::full_object_detection, std::allocator<dlib::full_object_detection> >, chip_filename: str, size: int=150, padding: float=0.25) -> None\n\nTakes an image and a full_object_detections object that reference faces in that image and saves the faces with the specified file name prefix.  The faces will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.\n'
    pass

def save_libsvm_formatted_data(file_name: str, samples: dlib.sparse_vectors, labels: dlib.array):
    'save_libsvm_formatted_data(file_name: str, samples: dlib.sparse_vectors, labels: dlib.array) -> None\n\nrequires    \n    - len(samples) == len(labels)    \nensures    \n    - saves the data to the given file in libsvm format   \n'
    pass

class segmenter_params(_mod_pybind11_builtins.pybind11_object):
    'This class is used to define all the optional parameters to the    \ntrain_sequence_segmenter() and cross_validate_sequence_segmenter() routines.   '
    C = _mod_builtins.property()
    __class__ = segmenter_params
    def __getstate__(self: dlib.segmenter_params):
        '__getstate__(self: dlib.segmenter_params) -> tuple\n'
        pass
    
    def __init__(self: dlib.segmenter_params):
        '__init__(self: dlib.segmenter_params) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib.segmenter_params):
        '__repr__(self: dlib.segmenter_params) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.segmenter_params, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.segmenter_params):
        '__str__(self: dlib.segmenter_params) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    allow_negative_weights = _mod_builtins.property()
    be_verbose = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    max_cache_size = _mod_builtins.property()
    num_threads = _mod_builtins.property()
    use_BIO_model = _mod_builtins.property()
    use_high_order_features = _mod_builtins.property()
    window_size = _mod_builtins.property()

class segmenter_test(_mod_pybind11_builtins.pybind11_object):
    'This object is the output of the dlib.test_sequence_segmenter() and dlib.cross_validate_sequence_segmenter() routines.'
    __class__ = segmenter_test
    def __getstate__(self: dlib.segmenter_test):
        '__getstate__(self: dlib.segmenter_test) -> tuple\n'
        pass
    
    def __init__(self):
        'This object is the output of the dlib.test_sequence_segmenter() and dlib.cross_validate_sequence_segmenter() routines.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __repr__(self: dlib.segmenter_test):
        '__repr__(self: dlib.segmenter_test) -> str\n'
        return ''
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.segmenter_test, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.segmenter_test):
        '__str__(self: dlib.segmenter_test) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    f1 = _mod_builtins.property()
    precision = _mod_builtins.property()
    recall = _mod_builtins.property()

class segmenter_type(_mod_pybind11_builtins.pybind11_object):
    'This object represents a sequence segmenter and is the type of object returned by the dlib.train_sequence_segmenter() routine.'
    def __call__(self, *args, **kwargs):
        '__call__(*args, **kwargs)\nOverloaded function.\n\n1. __call__(self: dlib.segmenter_type, arg0: dlib.vectors) -> dlib.ranges\n\n2. __call__(self: dlib.segmenter_type, arg0: dlib.sparse_vectors) -> dlib.ranges\n'
        pass
    
    __class__ = segmenter_type
    def __getstate__(self: dlib.segmenter_type):
        '__getstate__(self: dlib.segmenter_type) -> tuple\n'
        pass
    
    def __init__(self):
        'This object represents a sequence segmenter and is the type of object returned by the dlib.train_sequence_segmenter() routine.'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.segmenter_type, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    weights = _mod_builtins.property()

def set_dnn_prefer_smallest_algorithms():
    'set_dnn_prefer_smallest_algorithms() -> None\n\nTells cuDNN to use slower algorithms that use less RAM.\n'
    pass

class shape_predictor(_mod_pybind11_builtins.pybind11_object):
    'This object is a tool that takes in an image region containing some object and outputs a set of point locations that define the pose of the object. The classic example of this is human face pose prediction, where you take an image of a human face as input and are expected to identify the locations of important facial landmarks such as the corners of the mouth and eyes, tip of the nose, and so forth.'
    def __call__(self: dlib.shape_predictor, image: object, box: object):
        '__call__(self: dlib.shape_predictor, image: object, box: object) -> dlib.full_object_detection\n\nrequires \n    - image is a numpy ndarray containing either an 8bit grayscale or RGB \n      image. \n    - box is the bounding box to begin the shape prediction inside. \nensures \n    - This function runs the shape predictor on the input image and returns \n      a single full_object_detection.\n'
        pass
    
    __class__ = shape_predictor
    def __getstate__(self: dlib.shape_predictor):
        '__getstate__(self: dlib.shape_predictor) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.shape_predictor) -> None\n\n2. __init__(self: dlib.shape_predictor, arg0: str) -> None\n\nLoads a shape_predictor from a file that contains the output of the \ntrain_shape_predictor() routine.\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.shape_predictor, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def save(self: dlib.shape_predictor, predictor_output_filename: str):
        'save(self: dlib.shape_predictor, predictor_output_filename: str) -> None\n\nSave a shape_predictor to the provided path.\n'
        pass
    

class shape_predictor_training_options(_mod_pybind11_builtins.pybind11_object):
    'This object is a container for the options to the train_shape_predictor() routine.'
    __class__ = shape_predictor_training_options
    def __getstate__(self: dlib.shape_predictor_training_options):
        '__getstate__(self: dlib.shape_predictor_training_options) -> tuple\n'
        pass
    
    def __init__(self):
        '__init__(self: dlib.shape_predictor_training_options) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.shape_predictor_training_options, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.shape_predictor_training_options):
        '__str__(self: dlib.shape_predictor_training_options) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    be_verbose = _mod_builtins.property()
    cascade_depth = _mod_builtins.property()
    feature_pool_region_padding = _mod_builtins.property()
    feature_pool_size = _mod_builtins.property()
    lambda_param = _mod_builtins.property()
    nu = _mod_builtins.property()
    num_test_splits = _mod_builtins.property()
    num_threads = _mod_builtins.property()
    num_trees_per_cascade_level = _mod_builtins.property()
    oversampling_amount = _mod_builtins.property()
    random_seed = _mod_builtins.property()
    tree_depth = _mod_builtins.property()

class simple_object_detector(_mod_pybind11_builtins.pybind11_object):
    'This object represents a sliding window histogram-of-oriented-gradients based object detector.'
    def __call__(self, *args, **kwargs):
        "__call__(*args, **kwargs)\nOverloaded function.\n\n1. __call__(self: dlib.simple_object_detector, image: object, upsample_num_times: int) -> dlib.rectangles\n\nrequires \n    - image is a numpy ndarray containing either an 8bit grayscale or RGB \n      image. \n    - upsample_num_times >= 0 \nensures \n    - This function runs the object detector on the input image and returns \n      a list of detections.   \n    - Upsamples the image upsample_num_times before running the basic \n      detector.  If you don't know how many times you want to upsample then \n      don't provide a value for upsample_num_times and an appropriate \n      default will be used.\n\n2. __call__(self: dlib.simple_object_detector, image: object) -> dlib.rectangles\n\nrequires \n    - image is a numpy ndarray containing either an 8bit grayscale or RGB \n      image. \nensures \n    - This function runs the object detector on the input image and returns \n      a list of detections.\n"
        pass
    
    __class__ = simple_object_detector
    def __getstate__(self: dlib.simple_object_detector):
        '__getstate__(self: dlib.simple_object_detector) -> tuple\n'
        pass
    
    def __init__(self: dlib.simple_object_detector, arg0: str):
        '__init__(self: dlib.simple_object_detector, arg0: str) -> None\n\nLoads a simple_object_detector from a file that contains the output of the \ntrain_simple_object_detector() routine.\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.simple_object_detector, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def save(self: dlib.simple_object_detector, detector_output_filename: str):
        'save(self: dlib.simple_object_detector, detector_output_filename: str) -> None\n\nSave a simple_object_detector to the provided path.\n'
        pass
    

class simple_object_detector_training_options(_mod_pybind11_builtins.pybind11_object):
    'This object is a container for the options to the train_simple_object_detector() routine.'
    C = _mod_builtins.property()
    __class__ = simple_object_detector_training_options
    def __init__(self):
        '__init__(self: dlib.simple_object_detector_training_options) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    add_left_right_image_flips = _mod_builtins.property()
    be_verbose = _mod_builtins.property()
    detection_window_size = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    num_threads = _mod_builtins.property()
    upsample_limit = _mod_builtins.property()

class simple_test_results(_mod_pybind11_builtins.pybind11_object):
    __class__ = simple_test_results
    def __init__(self, *args, **kwargs):
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __str__(self: dlib.simple_test_results):
        '__str__(self: dlib.simple_test_results) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    average_precision = _mod_builtins.property()
    precision = _mod_builtins.property()
    recall = _mod_builtins.property()

def solve_structural_svm_problem(problem: object):
    'solve_structural_svm_problem(problem: object) -> dlib.vector\n\nThis function solves a structural SVM problem and returns the weight vector    \nthat defines the solution.  See the example program python_examples/svm_struct.py    \nfor documentation about how to create a proper problem object.   \n'
    pass

class sparse_ranking_pair(_mod_pybind11_builtins.pybind11_object):
    __class__ = sparse_ranking_pair
    def __getstate__(self: dlib.sparse_ranking_pair):
        '__getstate__(self: dlib.sparse_ranking_pair) -> tuple\n'
        pass
    
    def __init__(self: dlib.sparse_ranking_pair):
        '__init__(self: dlib.sparse_ranking_pair) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    def __setstate__(self, state):
        '__setstate__(self: dlib.sparse_ranking_pair, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    nonrelevant = _mod_builtins.property()
    relevant = _mod_builtins.property()

class sparse_ranking_pairs(_mod_pybind11_builtins.pybind11_object):
    def __bool__(self: dlib.sparse_ranking_pairs):
        '__bool__(self: dlib.sparse_ranking_pairs) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = sparse_ranking_pairs
    def __contains__(self, value):
        '__contains__(self: dlib.sparse_ranking_pairs, x: dlib.sparse_ranking_pair) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.sparse_ranking_pairs, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.sparse_ranking_pairs, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.sparse_ranking_pairs, arg0: dlib.sparse_ranking_pairs):
        '__eq__(self: dlib.sparse_ranking_pairs, arg0: dlib.sparse_ranking_pairs) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.sparse_ranking_pairs, s: slice) -> dlib.sparse_ranking_pairs\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.sparse_ranking_pairs, arg0: int) -> dlib.sparse_ranking_pair\n'
        pass
    
    def __getstate__(self: dlib.sparse_ranking_pairs):
        '__getstate__(self: dlib.sparse_ranking_pairs) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.sparse_ranking_pairs) -> None\n\n2. __init__(self: dlib.sparse_ranking_pairs, arg0: dlib.sparse_ranking_pairs) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.sparse_ranking_pairs, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.sparse_ranking_pairs):
        '__iter__(self: dlib.sparse_ranking_pairs) -> iterator\n'
        return sparse_ranking_pairs()
    
    def __len__(self: dlib.sparse_ranking_pairs):
        '__len__(self: dlib.sparse_ranking_pairs) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.sparse_ranking_pairs, arg0: dlib.sparse_ranking_pairs):
        '__ne__(self: dlib.sparse_ranking_pairs, arg0: dlib.sparse_ranking_pairs) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.sparse_ranking_pairs, arg0: int, arg1: dlib.sparse_ranking_pair) -> None\n\n2. __setitem__(self: dlib.sparse_ranking_pairs, arg0: slice, arg1: dlib.sparse_ranking_pairs) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.sparse_ranking_pairs, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.sparse_ranking_pairs, x: dlib.sparse_ranking_pair):
        'append(self: dlib.sparse_ranking_pairs, x: dlib.sparse_ranking_pair) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.sparse_ranking_pairs):
        'clear(self: dlib.sparse_ranking_pairs) -> None\n'
        pass
    
    def count(self: dlib.sparse_ranking_pairs, x: dlib.sparse_ranking_pair):
        'count(self: dlib.sparse_ranking_pairs, x: dlib.sparse_ranking_pair) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.sparse_ranking_pairs, L: dlib.sparse_ranking_pairs) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.sparse_ranking_pairs, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.sparse_ranking_pairs, i: int, x: dlib.sparse_ranking_pair):
        'insert(self: dlib.sparse_ranking_pairs, i: int, x: dlib.sparse_ranking_pair) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.sparse_ranking_pairs) -> dlib.sparse_ranking_pair\n\nRemove and return the last item\n\n2. pop(self: dlib.sparse_ranking_pairs, i: int) -> dlib.sparse_ranking_pair\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.sparse_ranking_pairs, x: dlib.sparse_ranking_pair):
        'remove(self: dlib.sparse_ranking_pairs, x: dlib.sparse_ranking_pair) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.sparse_ranking_pairs, arg0: int):
        'resize(self: dlib.sparse_ranking_pairs, arg0: int) -> None\n'
        pass
    

class sparse_vector(_mod_pybind11_builtins.pybind11_object):
    'This object represents the mathematical idea of a sparse column vector.  It is    \nsimply an array of dlib.pair objects, each representing an index/value pair in    \nthe vector.  Any elements of the vector which are missing are implicitly set to    \nzero.      \n    \nUnless otherwise noted, any routines taking a sparse_vector assume the sparse    \nvector is sorted and has unique elements.  That is, the index values of the    \npairs in a sparse_vector should be listed in increasing order and there should    \nnot be duplicates.  However, some functions work with "unsorted" sparse    \nvectors.  These are dlib.sparse_vector objects that have either duplicate    \nentries or non-sorted index values.  Note further that you can convert an    \n"unsorted" sparse_vector into a properly sorted sparse vector by calling    \ndlib.make_sparse_vector() on it.   '
    def __bool__(self: dlib.sparse_vector):
        '__bool__(self: dlib.sparse_vector) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = sparse_vector
    def __contains__(self, value):
        '__contains__(self: dlib.sparse_vector, x: dlib.pair) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.sparse_vector, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.sparse_vector, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.sparse_vector, arg0: dlib.sparse_vector):
        '__eq__(self: dlib.sparse_vector, arg0: dlib.sparse_vector) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.sparse_vector, s: slice) -> dlib.sparse_vector\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.sparse_vector, arg0: int) -> dlib.pair\n'
        pass
    
    def __getstate__(self: dlib.sparse_vector):
        '__getstate__(self: dlib.sparse_vector) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.sparse_vector) -> None\n\n2. __init__(self: dlib.sparse_vector, arg0: dlib.sparse_vector) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.sparse_vector, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.sparse_vector):
        '__iter__(self: dlib.sparse_vector) -> iterator\n'
        return sparse_vector()
    
    def __len__(self: dlib.sparse_vector):
        '__len__(self: dlib.sparse_vector) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.sparse_vector, arg0: dlib.sparse_vector):
        '__ne__(self: dlib.sparse_vector, arg0: dlib.sparse_vector) -> bool\n'
        return False
    
    def __repr__(self: dlib.sparse_vector):
        '__repr__(self: dlib.sparse_vector) -> str\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.sparse_vector, arg0: int, arg1: dlib.pair) -> None\n\n2. __setitem__(self: dlib.sparse_vector, arg0: slice, arg1: dlib.sparse_vector) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.sparse_vector, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.sparse_vector):
        '__str__(self: dlib.sparse_vector) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.sparse_vector, x: dlib.pair):
        'append(self: dlib.sparse_vector, x: dlib.pair) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.sparse_vector):
        'clear(self: dlib.sparse_vector) -> None\n'
        pass
    
    def count(self: dlib.sparse_vector, x: dlib.pair):
        'count(self: dlib.sparse_vector, x: dlib.pair) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.sparse_vector, L: dlib.sparse_vector) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.sparse_vector, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.sparse_vector, i: int, x: dlib.pair):
        'insert(self: dlib.sparse_vector, i: int, x: dlib.pair) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.sparse_vector) -> dlib.pair\n\nRemove and return the last item\n\n2. pop(self: dlib.sparse_vector, i: int) -> dlib.pair\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.sparse_vector, x: dlib.pair):
        'remove(self: dlib.sparse_vector, x: dlib.pair) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.sparse_vector, arg0: int):
        'resize(self: dlib.sparse_vector, arg0: int) -> None\n'
        pass
    

class sparse_vectors(_mod_pybind11_builtins.pybind11_object):
    'This object is an array of sparse_vector objects.'
    def __bool__(self: dlib.sparse_vectors):
        '__bool__(self: dlib.sparse_vectors) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = sparse_vectors
    def __contains__(self, value):
        '__contains__(self: dlib.sparse_vectors, x: dlib.sparse_vector) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.sparse_vectors, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.sparse_vectors, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.sparse_vectors, arg0: dlib.sparse_vectors):
        '__eq__(self: dlib.sparse_vectors, arg0: dlib.sparse_vectors) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.sparse_vectors, s: slice) -> dlib.sparse_vectors\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.sparse_vectors, arg0: int) -> dlib.sparse_vector\n'
        pass
    
    def __getstate__(self: dlib.sparse_vectors):
        '__getstate__(self: dlib.sparse_vectors) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.sparse_vectors) -> None\n\n2. __init__(self: dlib.sparse_vectors, arg0: dlib.sparse_vectors) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.sparse_vectors, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.sparse_vectors):
        '__iter__(self: dlib.sparse_vectors) -> iterator\n'
        return sparse_vectors()
    
    def __len__(self: dlib.sparse_vectors):
        '__len__(self: dlib.sparse_vectors) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.sparse_vectors, arg0: dlib.sparse_vectors):
        '__ne__(self: dlib.sparse_vectors, arg0: dlib.sparse_vectors) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.sparse_vectors, arg0: int, arg1: dlib.sparse_vector) -> None\n\n2. __setitem__(self: dlib.sparse_vectors, arg0: slice, arg1: dlib.sparse_vectors) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.sparse_vectors, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.sparse_vectors, x: dlib.sparse_vector):
        'append(self: dlib.sparse_vectors, x: dlib.sparse_vector) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.sparse_vectors):
        'clear(self: dlib.sparse_vectors) -> None\n'
        pass
    
    def count(self: dlib.sparse_vectors, x: dlib.sparse_vector):
        'count(self: dlib.sparse_vectors, x: dlib.sparse_vector) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.sparse_vectors, L: dlib.sparse_vectors) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.sparse_vectors, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.sparse_vectors, i: int, x: dlib.sparse_vector):
        'insert(self: dlib.sparse_vectors, i: int, x: dlib.sparse_vector) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.sparse_vectors) -> dlib.sparse_vector\n\nRemove and return the last item\n\n2. pop(self: dlib.sparse_vectors, i: int) -> dlib.sparse_vector\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.sparse_vectors, x: dlib.sparse_vector):
        'remove(self: dlib.sparse_vectors, x: dlib.sparse_vector) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.sparse_vectors, arg0: int):
        'resize(self: dlib.sparse_vectors, arg0: int) -> None\n'
        pass
    

class sparse_vectorss(_mod_pybind11_builtins.pybind11_object):
    'This object is an array of arrays of sparse_vector objects.'
    def __bool__(self: dlib.sparse_vectorss):
        '__bool__(self: dlib.sparse_vectorss) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = sparse_vectorss
    def __contains__(self, value):
        '__contains__(self: dlib.sparse_vectorss, x: dlib.sparse_vectors) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.sparse_vectorss, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.sparse_vectorss, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.sparse_vectorss, arg0: dlib.sparse_vectorss):
        '__eq__(self: dlib.sparse_vectorss, arg0: dlib.sparse_vectorss) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.sparse_vectorss, s: slice) -> dlib.sparse_vectorss\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.sparse_vectorss, arg0: int) -> dlib.sparse_vectors\n'
        pass
    
    def __getstate__(self: dlib.sparse_vectorss):
        '__getstate__(self: dlib.sparse_vectorss) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.sparse_vectorss) -> None\n\n2. __init__(self: dlib.sparse_vectorss, arg0: dlib.sparse_vectorss) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.sparse_vectorss, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.sparse_vectorss):
        '__iter__(self: dlib.sparse_vectorss) -> iterator\n'
        return sparse_vectorss()
    
    def __len__(self: dlib.sparse_vectorss):
        '__len__(self: dlib.sparse_vectorss) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.sparse_vectorss, arg0: dlib.sparse_vectorss):
        '__ne__(self: dlib.sparse_vectorss, arg0: dlib.sparse_vectorss) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.sparse_vectorss, arg0: int, arg1: dlib.sparse_vectors) -> None\n\n2. __setitem__(self: dlib.sparse_vectorss, arg0: slice, arg1: dlib.sparse_vectorss) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.sparse_vectorss, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.sparse_vectorss, x: dlib.sparse_vectors):
        'append(self: dlib.sparse_vectorss, x: dlib.sparse_vectors) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.sparse_vectorss):
        'clear(self: dlib.sparse_vectorss) -> None\n'
        pass
    
    def count(self: dlib.sparse_vectorss, x: dlib.sparse_vectors):
        'count(self: dlib.sparse_vectorss, x: dlib.sparse_vectors) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.sparse_vectorss, L: dlib.sparse_vectorss) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.sparse_vectorss, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.sparse_vectorss, i: int, x: dlib.sparse_vectors):
        'insert(self: dlib.sparse_vectorss, i: int, x: dlib.sparse_vectors) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.sparse_vectorss) -> dlib.sparse_vectors\n\nRemove and return the last item\n\n2. pop(self: dlib.sparse_vectorss, i: int) -> dlib.sparse_vectors\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.sparse_vectorss, x: dlib.sparse_vectors):
        'remove(self: dlib.sparse_vectorss, x: dlib.sparse_vectors) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.sparse_vectorss, arg0: int):
        'resize(self: dlib.sparse_vectorss, arg0: int) -> None\n'
        pass
    

class svm_c_trainer_histogram_intersection(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_c_trainer_histogram_intersection
    def __init__(self: dlib.svm_c_trainer_histogram_intersection):
        '__init__(self: dlib.svm_c_trainer_histogram_intersection) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    c_class1 = _mod_builtins.property()
    c_class2 = _mod_builtins.property()
    cache_size = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    def set_c(self: dlib.svm_c_trainer_histogram_intersection, arg0: float):
        'set_c(self: dlib.svm_c_trainer_histogram_intersection, arg0: float) -> None\n'
        pass
    
    def train(self: dlib.svm_c_trainer_histogram_intersection, arg0: dlib.vectors, arg1: dlib.array):
        'train(self: dlib.svm_c_trainer_histogram_intersection, arg0: dlib.vectors, arg1: dlib.array) -> dlib._decision_function_histogram_intersection\n'
        pass
    

class svm_c_trainer_linear(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_c_trainer_linear
    def __init__(self: dlib.svm_c_trainer_linear):
        '__init__(self: dlib.svm_c_trainer_linear) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def be_quiet(self: dlib.svm_c_trainer_linear):
        'be_quiet(self: dlib.svm_c_trainer_linear) -> None\n'
        pass
    
    def be_verbose(self: dlib.svm_c_trainer_linear):
        'be_verbose(self: dlib.svm_c_trainer_linear) -> None\n'
        pass
    
    c_class1 = _mod_builtins.property()
    c_class2 = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    force_last_weight_to_1 = _mod_builtins.property()
    has_prior = _mod_builtins.property()
    learns_nonnegative_weights = _mod_builtins.property()
    max_iterations = _mod_builtins.property()
    def set_c(self: dlib.svm_c_trainer_linear, arg0: float):
        'set_c(self: dlib.svm_c_trainer_linear, arg0: float) -> None\n'
        pass
    
    def set_prior(self: dlib.svm_c_trainer_linear, arg0: dlib._decision_function_linear):
        'set_prior(self: dlib.svm_c_trainer_linear, arg0: dlib._decision_function_linear) -> None\n'
        pass
    
    def train(self: dlib.svm_c_trainer_linear, arg0: dlib.vectors, arg1: dlib.array):
        'train(self: dlib.svm_c_trainer_linear, arg0: dlib.vectors, arg1: dlib.array) -> dlib._decision_function_linear\n'
        pass
    

class svm_c_trainer_radial_basis(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_c_trainer_radial_basis
    def __init__(self: dlib.svm_c_trainer_radial_basis):
        '__init__(self: dlib.svm_c_trainer_radial_basis) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    c_class1 = _mod_builtins.property()
    c_class2 = _mod_builtins.property()
    cache_size = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    gamma = _mod_builtins.property()
    def set_c(self: dlib.svm_c_trainer_radial_basis, arg0: float):
        'set_c(self: dlib.svm_c_trainer_radial_basis, arg0: float) -> None\n'
        pass
    
    def train(self: dlib.svm_c_trainer_radial_basis, arg0: dlib.vectors, arg1: dlib.array):
        'train(self: dlib.svm_c_trainer_radial_basis, arg0: dlib.vectors, arg1: dlib.array) -> dlib._decision_function_radial_basis\n'
        pass
    

class svm_c_trainer_sparse_histogram_intersection(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_c_trainer_sparse_histogram_intersection
    def __init__(self: dlib.svm_c_trainer_sparse_histogram_intersection):
        '__init__(self: dlib.svm_c_trainer_sparse_histogram_intersection) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    c_class1 = _mod_builtins.property()
    c_class2 = _mod_builtins.property()
    cache_size = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    def set_c(self: dlib.svm_c_trainer_sparse_histogram_intersection, arg0: float):
        'set_c(self: dlib.svm_c_trainer_sparse_histogram_intersection, arg0: float) -> None\n'
        pass
    
    def train(self: dlib.svm_c_trainer_sparse_histogram_intersection, arg0: dlib.sparse_vectors, arg1: dlib.array):
        'train(self: dlib.svm_c_trainer_sparse_histogram_intersection, arg0: dlib.sparse_vectors, arg1: dlib.array) -> dlib._decision_function_sparse_histogram_intersection\n'
        pass
    

class svm_c_trainer_sparse_linear(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_c_trainer_sparse_linear
    def __init__(self: dlib.svm_c_trainer_sparse_linear):
        '__init__(self: dlib.svm_c_trainer_sparse_linear) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def be_quiet(self: dlib.svm_c_trainer_sparse_linear):
        'be_quiet(self: dlib.svm_c_trainer_sparse_linear) -> None\n'
        pass
    
    def be_verbose(self: dlib.svm_c_trainer_sparse_linear):
        'be_verbose(self: dlib.svm_c_trainer_sparse_linear) -> None\n'
        pass
    
    c_class1 = _mod_builtins.property()
    c_class2 = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    force_last_weight_to_1 = _mod_builtins.property()
    has_prior = _mod_builtins.property()
    learns_nonnegative_weights = _mod_builtins.property()
    max_iterations = _mod_builtins.property()
    def set_c(self: dlib.svm_c_trainer_sparse_linear, arg0: float):
        'set_c(self: dlib.svm_c_trainer_sparse_linear, arg0: float) -> None\n'
        pass
    
    def set_prior(self: dlib.svm_c_trainer_sparse_linear, arg0: dlib._decision_function_sparse_linear):
        'set_prior(self: dlib.svm_c_trainer_sparse_linear, arg0: dlib._decision_function_sparse_linear) -> None\n'
        pass
    
    def train(self: dlib.svm_c_trainer_sparse_linear, arg0: dlib.sparse_vectors, arg1: dlib.array):
        'train(self: dlib.svm_c_trainer_sparse_linear, arg0: dlib.sparse_vectors, arg1: dlib.array) -> dlib._decision_function_sparse_linear\n'
        pass
    

class svm_c_trainer_sparse_radial_basis(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_c_trainer_sparse_radial_basis
    def __init__(self: dlib.svm_c_trainer_sparse_radial_basis):
        '__init__(self: dlib.svm_c_trainer_sparse_radial_basis) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    c_class1 = _mod_builtins.property()
    c_class2 = _mod_builtins.property()
    cache_size = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    gamma = _mod_builtins.property()
    def set_c(self: dlib.svm_c_trainer_sparse_radial_basis, arg0: float):
        'set_c(self: dlib.svm_c_trainer_sparse_radial_basis, arg0: float) -> None\n'
        pass
    
    def train(self: dlib.svm_c_trainer_sparse_radial_basis, arg0: dlib.sparse_vectors, arg1: dlib.array):
        'train(self: dlib.svm_c_trainer_sparse_radial_basis, arg0: dlib.sparse_vectors, arg1: dlib.array) -> dlib._decision_function_sparse_radial_basis\n'
        pass
    

class svm_rank_trainer(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_rank_trainer
    def __init__(self: dlib.svm_rank_trainer):
        '__init__(self: dlib.svm_rank_trainer) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def be_quiet(self: dlib.svm_rank_trainer):
        'be_quiet(self: dlib.svm_rank_trainer) -> None\n'
        pass
    
    def be_verbose(self: dlib.svm_rank_trainer):
        'be_verbose(self: dlib.svm_rank_trainer) -> None\n'
        pass
    
    c = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    force_last_weight_to_1 = _mod_builtins.property()
    has_prior = _mod_builtins.property()
    learns_nonnegative_weights = _mod_builtins.property()
    max_iterations = _mod_builtins.property()
    def set_prior(self: dlib.svm_rank_trainer, arg0, l, l_, dlib, dlib_):
        'set_prior(self: dlib.svm_rank_trainer, arg0: dlib::decision_function<dlib::linear_kernel<dlib::matrix<double, 0l, 1l, dlib::memory_manager_stateless_kernel_1<char>, dlib::row_major_layout> > >) -> None\n'
        pass
    
    def train(self, *args, **kwargs):
        'train(*args, **kwargs)\nOverloaded function.\n\n1. train(self: dlib.svm_rank_trainer, arg0: dlib.ranking_pair) -> dlib::decision_function<dlib::linear_kernel<dlib::matrix<double, 0l, 1l, dlib::memory_manager_stateless_kernel_1<char>, dlib::row_major_layout> > >\n\n2. train(self: dlib.svm_rank_trainer, arg0: dlib.ranking_pairs) -> dlib::decision_function<dlib::linear_kernel<dlib::matrix<double, 0l, 1l, dlib::memory_manager_stateless_kernel_1<char>, dlib::row_major_layout> > >\n'
        pass
    

class svm_rank_trainer_sparse(_mod_pybind11_builtins.pybind11_object):
    __class__ = svm_rank_trainer_sparse
    def __init__(self: dlib.svm_rank_trainer_sparse):
        '__init__(self: dlib.svm_rank_trainer_sparse) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    __module__ = 'dlib'
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def be_quiet(self: dlib.svm_rank_trainer_sparse):
        'be_quiet(self: dlib.svm_rank_trainer_sparse) -> None\n'
        pass
    
    def be_verbose(self: dlib.svm_rank_trainer_sparse):
        'be_verbose(self: dlib.svm_rank_trainer_sparse) -> None\n'
        pass
    
    c = _mod_builtins.property()
    epsilon = _mod_builtins.property()
    force_last_weight_to_1 = _mod_builtins.property()
    has_prior = _mod_builtins.property()
    learns_nonnegative_weights = _mod_builtins.property()
    max_iterations = _mod_builtins.property()
    def set_prior(self: dlib.svm_rank_trainer_sparse, arg0, double, std, double_):
        'set_prior(self: dlib.svm_rank_trainer_sparse, arg0: dlib::decision_function<dlib::sparse_linear_kernel<std::vector<std::pair<unsigned long, double>, std::allocator<std::pair<unsigned long, double> > > > >) -> None\n'
        pass
    
    def train(self, *args, **kwargs):
        'train(*args, **kwargs)\nOverloaded function.\n\n1. train(self: dlib.svm_rank_trainer_sparse, arg0: dlib.sparse_ranking_pair) -> dlib::decision_function<dlib::sparse_linear_kernel<std::vector<std::pair<unsigned long, double>, std::allocator<std::pair<unsigned long, double> > > > >\n\n2. train(self: dlib.svm_rank_trainer_sparse, arg0: dlib.sparse_ranking_pairs) -> dlib::decision_function<dlib::sparse_linear_kernel<std::vector<std::pair<unsigned long, double>, std::allocator<std::pair<unsigned long, double> > > > >\n'
        pass
    

def test_binary_decision_function(*args, **kwargs):
    'test_binary_decision_function(*args, **kwargs)\nOverloaded function.\n\n1. test_binary_decision_function(function: dlib._decision_function_linear, samples: dlib.vectors, labels: dlib.array) -> binary_test\n\n2. test_binary_decision_function(function: dlib._decision_function_sparse_linear, samples: dlib.sparse_vectors, labels: dlib.array) -> binary_test\n\n3. test_binary_decision_function(function: dlib._decision_function_radial_basis, samples: dlib.vectors, labels: dlib.array) -> binary_test\n\n4. test_binary_decision_function(function: dlib._decision_function_sparse_radial_basis, samples: dlib.sparse_vectors, labels: dlib.array) -> binary_test\n\n5. test_binary_decision_function(function: dlib._decision_function_polynomial, samples: dlib.vectors, labels: dlib.array) -> binary_test\n\n6. test_binary_decision_function(function: dlib._decision_function_sparse_polynomial, samples: dlib.sparse_vectors, labels: dlib.array) -> binary_test\n\n7. test_binary_decision_function(function: dlib._decision_function_histogram_intersection, samples: dlib.vectors, labels: dlib.array) -> binary_test\n\n8. test_binary_decision_function(function: dlib._decision_function_sparse_histogram_intersection, samples: dlib.sparse_vectors, labels: dlib.array) -> binary_test\n\n9. test_binary_decision_function(function: dlib._decision_function_sigmoid, samples: dlib.vectors, labels: dlib.array) -> binary_test\n\n10. test_binary_decision_function(function: dlib._decision_function_sparse_sigmoid, samples: dlib.sparse_vectors, labels: dlib.array) -> binary_test\n'
    pass

def test_ranking_function(*args, **kwargs):
    'test_ranking_function(*args, **kwargs)\nOverloaded function.\n\n1. test_ranking_function(function: dlib._decision_function_linear, samples: dlib.ranking_pairs) -> ranking_test\n\n2. test_ranking_function(function: dlib._decision_function_sparse_linear, samples: dlib.sparse_ranking_pairs) -> ranking_test\n\n3. test_ranking_function(function: dlib._decision_function_linear, sample: dlib.ranking_pair) -> ranking_test\n\n4. test_ranking_function(function: dlib._decision_function_sparse_linear, sample: dlib.sparse_ranking_pair) -> ranking_test\n'
    pass

def test_regression_function(*args, **kwargs):
    'test_regression_function(*args, **kwargs)\nOverloaded function.\n\n1. test_regression_function(function: dlib._decision_function_linear, samples: dlib.vectors, targets: dlib.array) -> regression_test\n\n2. test_regression_function(function: dlib._decision_function_sparse_linear, samples: dlib.sparse_vectors, targets: dlib.array) -> regression_test\n\n3. test_regression_function(function: dlib._decision_function_radial_basis, samples: dlib.vectors, targets: dlib.array) -> regression_test\n\n4. test_regression_function(function: dlib._decision_function_sparse_radial_basis, samples: dlib.sparse_vectors, targets: dlib.array) -> regression_test\n\n5. test_regression_function(function: dlib._decision_function_histogram_intersection, samples: dlib.vectors, targets: dlib.array) -> regression_test\n\n6. test_regression_function(function: dlib._decision_function_sparse_histogram_intersection, samples: dlib.sparse_vectors, targets: dlib.array) -> regression_test\n\n7. test_regression_function(function: dlib._decision_function_sigmoid, samples: dlib.vectors, targets: dlib.array) -> regression_test\n\n8. test_regression_function(function: dlib._decision_function_sparse_sigmoid, samples: dlib.sparse_vectors, targets: dlib.array) -> regression_test\n\n9. test_regression_function(function: dlib._decision_function_polynomial, samples: dlib.vectors, targets: dlib.array) -> regression_test\n\n10. test_regression_function(function: dlib._decision_function_sparse_polynomial, samples: dlib.sparse_vectors, targets: dlib.array) -> regression_test\n'
    pass

def test_sequence_segmenter(*args, **kwargs):
    'test_sequence_segmenter(*args, **kwargs)\nOverloaded function.\n\n1. test_sequence_segmenter(arg0: dlib.segmenter_type, arg1: dlib.vectorss, arg2: dlib.rangess) -> dlib.segmenter_test\n\n2. test_sequence_segmenter(arg0: dlib.segmenter_type, arg1: dlib.sparse_vectorss, arg2: dlib.rangess) -> dlib.segmenter_test\n'
    pass

def test_shape_predictor(*args, **kwargs):
    "test_shape_predictor(*args, **kwargs)\nOverloaded function.\n\n1. test_shape_predictor(dataset_filename: str, predictor_filename: str) -> float\n\nensures \n    - Loads an image dataset from dataset_filename.  We assume dataset_filename is \n      a file using the XML format written by save_image_dataset_metadata(). \n    - Loads a shape_predictor from the file predictor_filename.  This means \n      predictor_filename should be a file produced by the train_shape_predictor() \n      routine. \n    - This function tests the predictor against the dataset and returns the \n      mean average error of the detector.  In fact, The \n      return value of this function is identical to that of dlib's \n      shape_predictor_trainer() routine.  Therefore, see the documentation \n      for shape_predictor_trainer() for a detailed definition of the mean average error.\n\n2. test_shape_predictor(images: list, detections: list, shape_predictor: dlib.shape_predictor) -> float\n\nrequires \n    - len(images) == len(object_detections) \n    - images should be a list of numpy matrices that represent images, either RGB or grayscale. \n    - object_detections should be a list of lists of dlib.full_object_detection objects.       Each dlib.full_object_detection contains the bounding box and the lists of points that make up the object parts.\n ensures \n    - shape_predictor should be a file produced by the train_shape_predictor()  \n      routine. \n    - This function tests the predictor against the dataset and returns the \n      mean average error of the detector.  In fact, The \n      return value of this function is identical to that of dlib's \n      shape_predictor_trainer() routine.  Therefore, see the documentation \n      for shape_predictor_trainer() for a detailed definition of the mean average error.\n\n3. test_shape_predictor(images: list, detections: list, scales: list, shape_predictor: dlib.shape_predictor) -> float\n\nrequires \n    - len(images) == len(object_detections) \n    - len(object_detections) == len(scales) \n    - for every sublist in object_detections: len(object_detections[i]) == len(scales[i]) \n    - scales is a list of floating point scales that each predicted part location       should be divided by. Useful for normalization. \n    - images should be a list of numpy matrices that represent images, either RGB or grayscale. \n    - object_detections should be a list of lists of dlib.full_object_detection objects.       Each dlib.full_object_detection contains the bounding box and the lists of points that make up the object parts.\n ensures \n    - shape_predictor should be a file produced by the train_shape_predictor()  \n      routine. \n    - This function tests the predictor against the dataset and returns the \n      mean average error of the detector.  In fact, The \n      return value of this function is identical to that of dlib's \n      shape_predictor_trainer() routine.  Therefore, see the documentation \n      for shape_predictor_trainer() for a detailed definition of the mean average error.\n"
    pass

def test_simple_object_detector(*args, **kwargs):
    "test_simple_object_detector(*args, **kwargs)\nOverloaded function.\n\n1. test_simple_object_detector(dataset_filename: str, detector_filename: str, upsampling_amount: int=-1) -> dlib.simple_test_results\n\nrequires \n                - Optionally, take the number of times to upsample the testing images (upsampling_amount >= 0). \n             ensures \n                - Loads an image dataset from dataset_filename.  We assume dataset_filename is \n                  a file using the XML format written by save_image_dataset_metadata(). \n                - Loads a simple_object_detector from the file detector_filename.  This means \n                  detector_filename should be a file produced by the train_simple_object_detector()  \n                  routine. \n                - This function tests the detector against the dataset and returns the \n                  precision, recall, and average precision of the detector.  In fact, The \n                  return value of this function is identical to that of dlib's \n                  test_object_detection_function() routine.  Therefore, see the documentation \n                  for test_object_detection_function() for a detailed definition of these \n                  metrics. \n\n2. test_simple_object_detector(images: list, boxes: list, detector: dlib::object_detector<dlib::scan_fhog_pyramid<dlib::pyramid_down<6u>, dlib::default_fhog_feature_extractor> >, upsampling_amount: int=0) -> dlib.simple_test_results\n\nrequires \n               - len(images) == len(boxes) \n               - images should be a list of numpy matrices that represent images, either RGB or grayscale. \n               - boxes should be a list of lists of dlib.rectangle object. \n               - Optionally, take the number of times to upsample the testing images (upsampling_amount >= 0). \n             ensures \n               - Loads a simple_object_detector from the file detector_filename.  This means \n                 detector_filename should be a file produced by the train_simple_object_detector() \n                 routine. \n               - This function tests the detector against the dataset and returns the \n                 precision, recall, and average precision of the detector.  In fact, The \n                 return value of this function is identical to that of dlib's \n                 test_object_detection_function() routine.  Therefore, see the documentation \n                 for test_object_detection_function() for a detailed definition of these \n                 metrics. \n\n3. test_simple_object_detector(images: list, boxes: list, detector: dlib::simple_object_detector_py, upsampling_amount: int=-1) -> dlib.simple_test_results\n\nrequires \n               - len(images) == len(boxes) \n               - images should be a list of numpy matrices that represent images, either RGB or grayscale. \n               - boxes should be a list of lists of dlib.rectangle object. \n             ensures \n               - Loads a simple_object_detector from the file detector_filename.  This means \n                 detector_filename should be a file produced by the train_simple_object_detector() \n                 routine. \n               - This function tests the detector against the dataset and returns the \n                 precision, recall, and average precision of the detector.  In fact, The \n                 return value of this function is identical to that of dlib's \n                 test_object_detection_function() routine.  Therefore, see the documentation \n                 for test_object_detection_function() for a detailed definition of these \n                 metrics. \n"
    pass

def train_sequence_segmenter(*args, **kwargs):
    'train_sequence_segmenter(*args, **kwargs)\nOverloaded function.\n\n1. train_sequence_segmenter(samples: dlib.vectorss, segments: dlib.rangess, params: dlib.segmenter_params=<BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100>) -> dlib.segmenter_type\n\n2. train_sequence_segmenter(samples: dlib.sparse_vectorss, segments: dlib.rangess, params: dlib.segmenter_params=<BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100>) -> dlib.segmenter_type\n'
    pass

def train_shape_predictor(*args, **kwargs):
    "train_shape_predictor(*args, **kwargs)\nOverloaded function.\n\n1. train_shape_predictor(images: list, object_detections: list, options: dlib.shape_predictor_training_options) -> dlib.shape_predictor\n\nrequires \n    - options.lambda_param > 0 \n    - 0 < options.nu <= 1 \n    - options.feature_pool_region_padding >= 0 \n    - len(images) == len(object_detections) \n    - images should be a list of numpy matrices that represent images, either RGB or grayscale. \n    - object_detections should be a list of lists of dlib.full_object_detection objects.       Each dlib.full_object_detection contains the bounding box and the lists of points that make up the object parts.\nensures \n    - Uses dlib's shape_predictor_trainer object to train a \n      shape_predictor based on the provided labeled images, full_object_detections, and options.\n    - The trained shape_predictor is returned\n\n2. train_shape_predictor(dataset_filename: str, predictor_output_filename: str, options: dlib.shape_predictor_training_options) -> None\n\nrequires \n    - options.lambda_param > 0 \n    - 0 < options.nu <= 1 \n    - options.feature_pool_region_padding >= 0 \nensures \n    - Uses dlib's shape_predictor_trainer to train a \n      shape_predictor based on the labeled images in the XML file \n      dataset_filename and the provided options.  This function assumes the file dataset_filename is in the \n      XML format produced by dlib's save_image_dataset_metadata() routine. \n    - The trained shape predictor is serialized to the file predictor_output_filename.\n"
    pass

def train_simple_object_detector(*args, **kwargs):
    "train_simple_object_detector(*args, **kwargs)\nOverloaded function.\n\n1. train_simple_object_detector(dataset_filename: str, detector_output_filename: str, options: dlib.simple_object_detector_training_options) -> None\n\nrequires \n    - options.C > 0 \nensures \n    - Uses the structural_object_detection_trainer to train a \n      simple_object_detector based on the labeled images in the XML file \n      dataset_filename.  This function assumes the file dataset_filename is in the \n      XML format produced by dlib's save_image_dataset_metadata() routine. \n    - This function will apply a reasonable set of default parameters and \n      preprocessing techniques to the training procedure for simple_object_detector \n      objects.  So the point of this function is to provide you with a very easy \n      way to train a basic object detector.   \n    - The trained object detector is serialized to the file detector_output_filename.\n\n2. train_simple_object_detector(images: list, boxes: list, options: dlib.simple_object_detector_training_options) -> dlib::simple_object_detector_py\n\nrequires \n    - options.C > 0 \n    - len(images) == len(boxes) \n    - images should be a list of numpy matrices that represent images, either RGB or grayscale. \n    - boxes should be a list of lists of dlib.rectangle object. \nensures \n    - Uses the structural_object_detection_trainer to train a \n      simple_object_detector based on the labeled images and bounding boxes.  \n    - This function will apply a reasonable set of default parameters and \n      preprocessing techniques to the training procedure for simple_object_detector \n      objects.  So the point of this function is to provide you with a very easy \n      way to train a basic object detector.   \n    - The trained object detector is returned.\n"
    pass

class vector(_mod_pybind11_builtins.pybind11_object):
    'This object represents the mathematical idea of a column vector.'
    __class__ = vector
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.vector, arg0: int) -> float\n\n2. __getitem__(self: dlib.vector, arg0: slice) -> dlib.vector\n'
        pass
    
    def __getstate__(self: dlib.vector):
        '__getstate__(self: dlib.vector) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.vector) -> None\n\n2. __init__(self: dlib.vector, arg0: object) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __len__(self: dlib.vector):
        '__len__(self: dlib.vector) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __repr__(self: dlib.vector):
        '__repr__(self: dlib.vector) -> str\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(self: dlib.vector, arg0: int, arg1: float) -> None\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.vector, arg0: tuple) -> None\n'
        return None
    
    def __str__(self: dlib.vector):
        '__str__(self: dlib.vector) -> str\n'
        return ''
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def resize(self: dlib.vector, arg0: int):
        'resize(self: dlib.vector, arg0: int) -> None\n'
        pass
    
    def set_size(self: dlib.vector, arg0: int):
        'set_size(self: dlib.vector, arg0: int) -> None\n'
        pass
    
    shape = _mod_builtins.property()

class vectors(_mod_pybind11_builtins.pybind11_object):
    'This object is an array of vector objects.'
    def __bool__(self: dlib.vectors):
        '__bool__(self: dlib.vectors) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = vectors
    def __contains__(self, value):
        '__contains__(self: dlib.vectors, x: dlib.vector) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.vectors, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.vectors, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.vectors, arg0: dlib.vectors):
        '__eq__(self: dlib.vectors, arg0: dlib.vectors) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.vectors, s: slice) -> dlib.vectors\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.vectors, arg0: int) -> dlib.vector\n'
        pass
    
    def __getstate__(self: dlib.vectors):
        '__getstate__(self: dlib.vectors) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.vectors) -> None\n\n2. __init__(self: dlib.vectors, arg0: dlib.vectors) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.vectors, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.vectors):
        '__iter__(self: dlib.vectors) -> iterator\n'
        return vectors()
    
    def __len__(self: dlib.vectors):
        '__len__(self: dlib.vectors) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.vectors, arg0: dlib.vectors):
        '__ne__(self: dlib.vectors, arg0: dlib.vectors) -> bool\n'
        return False
    
    def __repr__(self: dlib.vectors):
        '__repr__(self: dlib.vectors) -> str\n\nReturn the canonical string representation of this list.\n'
        return ''
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.vectors, arg0: int, arg1: dlib.vector) -> None\n\n2. __setitem__(self: dlib.vectors, arg0: slice, arg1: dlib.vectors) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.vectors, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.vectors, x: dlib.vector):
        'append(self: dlib.vectors, x: dlib.vector) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.vectors):
        'clear(self: dlib.vectors) -> None\n'
        pass
    
    def count(self: dlib.vectors, x: dlib.vector):
        'count(self: dlib.vectors, x: dlib.vector) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.vectors, L: dlib.vectors) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.vectors, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.vectors, i: int, x: dlib.vector):
        'insert(self: dlib.vectors, i: int, x: dlib.vector) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.vectors) -> dlib.vector\n\nRemove and return the last item\n\n2. pop(self: dlib.vectors, i: int) -> dlib.vector\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.vectors, x: dlib.vector):
        'remove(self: dlib.vectors, x: dlib.vector) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.vectors, arg0: int):
        'resize(self: dlib.vectors, arg0: int) -> None\n'
        pass
    

class vectorss(_mod_pybind11_builtins.pybind11_object):
    'This object is an array of arrays of vector objects.'
    def __bool__(self: dlib.vectorss):
        '__bool__(self: dlib.vectorss) -> bool\n\nCheck whether the list is nonempty\n'
        return False
    
    __class__ = vectorss
    def __contains__(self, value):
        '__contains__(self: dlib.vectorss, x: dlib.vectors) -> bool\n\nReturn true the container contains ``x``\n'
        return False
    
    def __delitem__(self, *args, **kwargs):
        '__delitem__(*args, **kwargs)\nOverloaded function.\n\n1. __delitem__(self: dlib.vectorss, arg0: int) -> None\n\nDelete the list elements at index ``i``\n\n2. __delitem__(self: dlib.vectorss, arg0: slice) -> None\n\nDelete list elements using a slice object\n'
        return None
    
    def __eq__(self: dlib.vectorss, arg0: dlib.vectorss):
        '__eq__(self: dlib.vectorss, arg0: dlib.vectorss) -> bool\n'
        return False
    
    def __getitem__(self, index):
        '__getitem__(*args, **kwargs)\nOverloaded function.\n\n1. __getitem__(self: dlib.vectorss, s: slice) -> dlib.vectorss\n\nRetrieve list elements using a slice object\n\n2. __getitem__(self: dlib.vectorss, arg0: int) -> dlib.vectors\n'
        pass
    
    def __getstate__(self: dlib.vectorss):
        '__getstate__(self: dlib.vectorss) -> tuple\n'
        pass
    
    def __init__(self, *args, **kwargs):
        '__init__(*args, **kwargs)\nOverloaded function.\n\n1. __init__(self: dlib.vectorss) -> None\n\n2. __init__(self: dlib.vectorss, arg0: dlib.vectorss) -> None\n\nCopy constructor\n\n3. __init__(self: dlib.vectorss, arg0: iterable) -> None\n'
        pass
    
    @classmethod
    def __init_subclass__(cls):
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        return None
    
    def __iter__(self: dlib.vectorss):
        '__iter__(self: dlib.vectorss) -> iterator\n'
        return vectorss()
    
    def __len__(self: dlib.vectorss):
        '__len__(self: dlib.vectorss) -> int\n'
        return 0
    
    __module__ = 'dlib'
    def __ne__(self: dlib.vectorss, arg0: dlib.vectorss):
        '__ne__(self: dlib.vectorss, arg0: dlib.vectorss) -> bool\n'
        return False
    
    def __setitem__(self, index, value):
        '__setitem__(*args, **kwargs)\nOverloaded function.\n\n1. __setitem__(self: dlib.vectorss, arg0: int, arg1: dlib.vectors) -> None\n\n2. __setitem__(self: dlib.vectorss, arg0: slice, arg1: dlib.vectorss) -> None\n\nAssign list elements using a slice object\n'
        return None
    
    def __setstate__(self, state):
        '__setstate__(self: dlib.vectorss, arg0: tuple) -> None\n'
        return None
    
    @classmethod
    def __subclasshook__(cls, subclass):
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        return False
    
    def append(self: dlib.vectorss, x: dlib.vectors):
        'append(self: dlib.vectorss, x: dlib.vectors) -> None\n\nAdd an item to the end of the list\n'
        pass
    
    def clear(self: dlib.vectorss):
        'clear(self: dlib.vectorss) -> None\n'
        pass
    
    def count(self: dlib.vectorss, x: dlib.vectors):
        'count(self: dlib.vectorss, x: dlib.vectors) -> int\n\nReturn the number of times ``x`` appears in the list\n'
        return 1
    
    def extend(self, *args, **kwargs):
        'extend(*args, **kwargs)\nOverloaded function.\n\n1. extend(self: dlib.vectorss, L: dlib.vectorss) -> None\n\nExtend the list by appending all the items in the given list\n\n2. extend(self: dlib.vectorss, arg0: list) -> None\n'
        pass
    
    def insert(self: dlib.vectorss, i: int, x: dlib.vectors):
        'insert(self: dlib.vectorss, i: int, x: dlib.vectors) -> None\n\nInsert an item at a given position.\n'
        pass
    
    def pop(self, *args, **kwargs):
        'pop(*args, **kwargs)\nOverloaded function.\n\n1. pop(self: dlib.vectorss) -> dlib.vectors\n\nRemove and return the last item\n\n2. pop(self: dlib.vectorss, i: int) -> dlib.vectors\n\nRemove and return the item at index ``i``\n'
        pass
    
    def remove(self: dlib.vectorss, x: dlib.vectors):
        'remove(self: dlib.vectorss, x: dlib.vectors) -> None\n\nRemove the first item from the list whose value is x. It is an error if there is no such item.\n'
        pass
    
    def resize(self: dlib.vectorss, arg0: int):
        'resize(self: dlib.vectorss, arg0: int) -> None\n'
        pass
    

