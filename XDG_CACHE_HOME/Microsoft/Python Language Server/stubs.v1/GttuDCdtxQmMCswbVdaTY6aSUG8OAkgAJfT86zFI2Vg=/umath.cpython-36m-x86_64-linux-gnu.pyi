import builtins as _mod_builtins

ERR_CALL = 3
ERR_DEFAULT = 521
ERR_IGNORE = 0
ERR_LOG = 5
ERR_PRINT = 4
ERR_RAISE = 2
ERR_WARN = 1
FLOATING_POINT_SUPPORT = 1
FPE_DIVIDEBYZERO = 1
FPE_INVALID = 8
FPE_OVERFLOW = 2
FPE_UNDERFLOW = 4
NAN = float('nan')
NINF = float('-inf')
NZERO = -0.0
PINF = float('inf')
PZERO = 0.0
SHIFT_DIVIDEBYZERO = 0
SHIFT_INVALID = 9
SHIFT_OVERFLOW = 3
SHIFT_UNDERFLOW = 6
UFUNC_BUFSIZE_DEFAULT = 8192
UFUNC_PYVALS_NAME = 'UFUNC_PYVALS'
_UFUNC_API = _mod_builtins.PyCapsule()
__doc__ = None
__file__ = '/home/lucas/anaconda3/envs/curso_dlib/lib/python3.6/site-packages/numpy/core/umath.cpython-36m-x86_64-linux-gnu.so'
__name__ = 'numpy.core.umath'
__package__ = 'numpy.core'
def _add_newdoc_ufunc():
    'add_ufunc_docstring(ufunc, new_docstring)\n\n    Replace the docstring for a ufunc with new_docstring.\n    This method will only work if the current docstring for\n    the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)\n\n    Parameters\n    ----------\n    ufunc : numpy.ufunc\n        A ufunc whose current doc is NULL.\n    new_docstring : string\n        The new docstring for the ufunc.\n\n    Notes\n    -----\n    This method allocates memory for new_docstring on\n    the heap. Technically this creates a mempory leak, since this\n    memory will not be reclaimed until the end of the program\n    even if the ufunc itself is removed. However this will only\n    be a problem if the user is repeatedly creating ufuncs with\n    no documentation, adding documentation via add_newdoc_ufunc,\n    and then throwing away the ufunc.'
    pass

def _arg(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "_arg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nDO NOT USE, ONLY FOR TESTING"
    pass

def _ones_like(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "_ones_like(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nThis function used to be the numpy.ones_like, but now a specific\nfunction for that has been written for consistency with the other\n*_like functions. It is only used internally in a limited fashion now.\n\nSee Also\n--------\nones_like"
    pass

def absolute(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate the absolute value element-wise.\n\n``np.abs`` is a shorthand for this function.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nabsolute : ndarray\n    An ndarray containing the absolute value of\n    each element in `x`.  For complex input, ``a + ib``, the\n    absolute value is :math:`\\sqrt{ a^2 + b^2 }`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> x = np.array([-1.2, 1.2])\n>>> np.absolute(x)\narray([ 1.2,  1.2])\n>>> np.absolute(1.2 + 1j)\n1.5620499351813308\n\nPlot the function over ``[-10, 10]``:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(start=-10, stop=10, num=101)\n>>> plt.plot(x, np.absolute(x))\n>>> plt.show()\n\nPlot the function over the complex plane:\n\n>>> xx = x + 1j * x[:, np.newaxis]\n>>> plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n>>> plt.show()"
    pass

def add(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nAdd arguments element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays to be added.  If ``x1.shape != x2.shape``, they must be\n    broadcastable to a common shape (which may be the shape of one or\n    the other).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nadd : ndarray or scalar\n    The sum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nEquivalent to `x1` + `x2` in terms of array broadcasting.\n\nExamples\n--------\n>>> np.add(1.0, 4.0)\n5.0\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])"
    pass

def arccos(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'arccos(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse cosine, element-wise.\n\nThe inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.\n\nParameters\n----------\nx : array_like\n    `x`-coordinate on the unit circle.\n    For real arguments, the domain is [-1, 1].\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nangle : ndarray\n    The angle of the ray intersecting the unit circle at the given\n    `x`-coordinate in radians [0, pi].\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\ncos, arctan, arcsin, emath.arccos\n\nNotes\n-----\n`arccos` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `cos(z) = x`. The convention is to return\nthe angle `z` whose real part lies in `[0, pi]`.\n\nFor real-valued input data types, `arccos` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccos` is a complex analytic function that\nhas branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\n\nThe inverse `cos` is also known as `acos` or cos^-1.\n\nReferences\n----------\nM. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",\n10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/\n\nExamples\n--------\nWe expect the arccos of 1 to be 0, and of -1 to be pi:\n\n>>> np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\n\nPlot arccos:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-1, 1, num=100)\n>>> plt.plot(x, np.arccos(x))\n>>> plt.axis(\'tight\')\n>>> plt.show()'
    pass

def arccosh(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'arccosh(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic cosine, element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\narccosh : ndarray\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\n\ncosh, arcsinh, sinh, arctanh, tanh\n\nNotes\n-----\n`arccosh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `cosh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi, pi]` and the real part in\n``[0, inf]``.\n\nFor real-valued input data types, `arccosh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccosh` is a complex analytical function that\nhas a branch cut `[-inf, 1]` and is continuous from above on it.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",\n       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, "Inverse hyperbolic function",\n       http://en.wikipedia.org/wiki/Arccosh\n\nExamples\n--------\n>>> np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n>>> np.arccosh(1)\n0.0'
    pass

def arcsin(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nInverse sine, element-wise.\n\nParameters\n----------\nx : array_like\n    `y`-coordinate on the unit circle.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nangle : ndarray\n    The inverse sine of each element in `x`, in radians and in the\n    closed interval ``[-pi/2, pi/2]``.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nsin, cos, arccos, tan, arctan, arctan2, emath.arcsin\n\nNotes\n-----\n`arcsin` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that :math:`sin(z) = x`.  The convention is to\nreturn the angle `z` whose real part lies in [-pi/2, pi/2].\n\nFor real-valued input data types, *arcsin* always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arcsin` is a complex analytic function that\nhas, by convention, the branch cuts [-inf, -1] and [1, inf]  and is\ncontinuous from above on the former and from below on the latter.\n\nThe inverse sine is also known as `asin` or sin^{-1}.\n\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79ff.\nhttp://www.math.sfu.ca/~cbm/aands/\n\nExamples\n--------\n>>> np.arcsin(1)     # pi/2\n1.5707963267948966\n>>> np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n>>> np.arcsin(0)\n0.0"
    pass

def arcsinh(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'arcsinh(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic sine element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\n`arcsinh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `sinh(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi/2, pi/2]`.\n\nFor real-valued input data types, `arcsinh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nreturns ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arccos` is a complex analytical function that\nhas branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from\nthe right on the former and from the left on the latter.\n\nThe inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",\n       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, "Inverse hyperbolic function",\n       http://en.wikipedia.org/wiki/Arcsinh\n\nExamples\n--------\n>>> np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])'
    pass

def arctan(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'arctan(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric inverse tangent, element-wise.\n\nThe inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.\n\nParameters\n----------\nx : array_like\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Out has the same shape as `x`.  Its real part is in\n    ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\narctan2 : The "four quadrant" arctan of the angle formed by (`x`, `y`)\n    and the positive `x`-axis.\nangle : Argument of complex values.\n\nNotes\n-----\n`arctan` is a multi-valued function: for each `x` there are infinitely\nmany numbers `z` such that tan(`z`) = `x`.  The convention is to return\nthe angle `z` whose real part lies in [-pi/2, pi/2].\n\nFor real-valued input data types, `arctan` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arctan` is a complex analytic function that\nhas [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous\nfrom the left on the former and from the right on the latter.\n\nThe inverse tangent is also known as `atan` or tan^{-1}.\n\nReferences\n----------\nAbramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,\n10th printing, New York: Dover, 1964, pp. 79.\nhttp://www.math.sfu.ca/~cbm/aands/\n\nExamples\n--------\nWe expect the arctan of 0 to be 0, and of 1 to be pi/4:\n\n>>> np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n\n>>> np.pi/4\n0.78539816339744828\n\nPlot arctan:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-10, 10)\n>>> plt.plot(x, np.arctan(x))\n>>> plt.axis(\'tight\')\n>>> plt.show()'
    pass

def arctan2(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'arctan2(x1, x2, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nElement-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.\n\nThe quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is\nthe signed angle in radians between the ray ending at the origin and\npassing through the point (1,0), and the ray ending at the origin and\npassing through the point (`x2`, `x1`).  (Note the role reversal: the\n"`y`-coordinate" is the first function parameter, the "`x`-coordinate"\nis the second.)  By IEEE convention, this function is defined for\n`x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see\nNotes for specific values).\n\nThis function is not defined for complex-valued arguments; for the\nso-called argument of complex values, use `angle`.\n\nParameters\n----------\nx1 : array_like, real-valued\n    `y`-coordinates.\nx2 : array_like, real-valued\n    `x`-coordinates. `x2` must be broadcastable to match the shape of\n    `x1` or vice versa.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nangle : ndarray\n    Array of angles in radians, in the range ``[-pi, pi]``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\narctan, tan, angle\n\nNotes\n-----\n*arctan2* is identical to the `atan2` function of the underlying\nC library.  The following special values are defined in the C\nstandard: [1]_\n\n====== ====== ================\n`x1`   `x2`   `arctan2(x1,x2)`\n====== ====== ================\n+/- 0  +0     +/- 0\n+/- 0  -0     +/- pi\n > 0   +/-inf +0 / +pi\n < 0   +/-inf -0 / -pi\n+/-inf +inf   +/- (pi/4)\n+/-inf -inf   +/- (3*pi/4)\n====== ====== ================\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf\nand -inf.\n\nReferences\n----------\n.. [1] ISO/IEC standard 9899:1999, "Programming language C."\n\nExamples\n--------\nConsider four points in different quadrants:\n\n>>> x = np.array([-1, +1, +1, -1])\n>>> y = np.array([-1, -1, +1, +1])\n>>> np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\n\nNote the order of the parameters. `arctan2` is defined also when `x2` = 0\nand at several other special points, obtaining values in\nthe range ``[-pi, pi]``:\n\n>>> np.arctan2([1., -1.], [0., 0.])\narray([ 1.57079633, -1.57079633])\n>>> np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\narray([ 0.        ,  3.14159265,  0.78539816])'
    pass

def arctanh(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'arctanh(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nInverse hyperbolic tangent element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Array of the same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nemath.arctanh\n\nNotes\n-----\n`arctanh` is a multivalued function: for each `x` there are infinitely\nmany numbers `z` such that `tanh(z) = x`. The convention is to return\nthe `z` whose imaginary part lies in `[-pi/2, pi/2]`.\n\nFor real-valued input data types, `arctanh` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `arctanh` is a complex analytical function\nthat has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from\nabove on the former and from below on the latter.\n\nThe inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",\n       10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, "Inverse hyperbolic function",\n       http://en.wikipedia.org/wiki/Arctanh\n\nExamples\n--------\n>>> np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])'
    pass

def bitwise_and(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``&``.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_and\nbitwise_or\nbitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 is represented by ``00001101``.  Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise AND of 13 and 17 is\ntherefore ``000000001``, or 1:\n\n>>> np.bitwise_and(13, 17)\n1\n\n>>> np.bitwise_and(14, 13)\n12\n>>> np.binary_repr(12)\n'1100'\n>>> np.bitwise_and([14,3], 13)\narray([12,  1])\n\n>>> np.bitwise_and([11,7], [4,25])\narray([0, 1])\n>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n>>> np.bitwise_and([True, True], [False, True])\narray([False,  True])"
    pass

def bitwise_or(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``|``.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_or\nbitwise_and\nbitwise_xor\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 has the binaray representation ``00001101``. Likewise,\n16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is\nthen ``000111011``, or 29:\n\n>>> np.bitwise_or(13, 16)\n29\n>>> np.binary_repr(29)\n'11101'\n\n>>> np.bitwise_or(32, 2)\n34\n>>> np.bitwise_or([33, 4], 1)\narray([33,  5])\n>>> np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n\n>>> np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n>>> np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n>>> np.bitwise_or(np.array([2, 5, 255, 2147483647L], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647L], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n>>> np.bitwise_or([True, True], [False, True])\narray([ True,  True])"
    pass

def bitwise_xor(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``^``.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_xor\nbitwise_and\nbitwise_or\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nExamples\n--------\nThe number 13 is represented by ``00001101``. Likewise, 17 is\nrepresented by ``00010001``.  The bit-wise XOR of 13 and 17 is\ntherefore ``00011100``, or 28:\n\n>>> np.bitwise_xor(13, 17)\n28\n>>> np.binary_repr(28)\n'11100'\n\n>>> np.bitwise_xor(31, 5)\n26\n>>> np.bitwise_xor([31,3], 5)\narray([26,  6])\n\n>>> np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n>>> np.bitwise_xor([True, True], [False, True])\narray([ True, False])"
    pass

def cbrt(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the cube-root of an array, element-wise.\n\n.. versionadded:: 1.10.0\n\nParameters\n----------\nx : array_like\n    The values whose cube-roots are required.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    An array of the same shape as `x`, containing the cube\n    cube-root of each element in `x`.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.\n\n\nExamples\n--------\n>>> np.cbrt([1,8,27])\narray([ 1.,  2.,  3.])"
    pass

def ceil(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the ceiling of the input, element-wise.\n\nThe ceil of the scalar `x` is the smallest integer `i`, such that\n`i >= x`.  It is often denoted as :math:`\\lceil x \\rceil`.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The ceiling of each element in `x`, with `float` dtype.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nfloor, trunc, rint\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])"
    pass

def conj():
    "conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the complex conjugate, element-wise.\n\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.\n\nParameters\n----------\nx : array_like\n    Input value.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The complex conjugate of `x`, with same dtype as `y`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.conjugate(1+2j)\n(1-2j)\n\n>>> x = np.eye(2) + 1j * np.eye(2)\n>>> np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])"
    pass

def conjugate(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the complex conjugate, element-wise.\n\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.\n\nParameters\n----------\nx : array_like\n    Input value.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The complex conjugate of `x`, with same dtype as `y`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.conjugate(1+2j)\n(1-2j)\n\n>>> x = np.eye(2) + 1j * np.eye(2)\n>>> np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])"
    pass

def copysign(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nChange the sign of x1 to that of x2, element-wise.\n\nIf both arguments are arrays or sequences, they have to be of the same\nlength. If `x2` is a scalar, its sign will be copied to all elements of\n`x1`.\n\nParameters\n----------\nx1 : array_like\n    Values to change the sign of.\nx2 : array_like\n    The sign of `x2` is copied to `x1`.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The values of `x1` with the sign of `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nExamples\n--------\n>>> np.copysign(1.3, -1)\n-1.3\n>>> 1/np.copysign(0, 1)\ninf\n>>> 1/np.copysign(0, -1)\n-inf\n\n>>> np.copysign([-1, 0, 1], -1.1)\narray([-1., -0., -1.])\n>>> np.copysign([-1, 0, 1], np.arange(3)-1)\narray([-1.,  0.,  1.])"
    pass

def cos(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'cos(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nCosine element-wise.\n\nParameters\n----------\nx : array_like\n    Input array in radians.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding cosine values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.\n\nExamples\n--------\n>>> np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n>>>\n>>> # Example of providing the optional output parameter\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape'
    pass

def cosh(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic cosine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) + np.exp(-x))`` and ``np.cos(1j*x)``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array of same shape as `x`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.cosh(0)\n1.0\n\nThe hyperbolic cosine describes the shape of a hanging cable:\n\n>>> import matplotlib.pyplot as plt\n>>> x = np.linspace(-4, 4, 1000)\n>>> plt.plot(x, np.cosh(x))\n>>> plt.show()"
    pass

def deg2rad(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from degrees to radians.\n\nParameters\n----------\nx : array_like\n    Angles in degrees.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding angle in radians.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nrad2deg : Convert angles from radians to degrees.\nunwrap : Remove large jumps in angle by wrapping.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\n``deg2rad(x)`` is ``x * pi / 180``.\n\nExamples\n--------\n>>> np.deg2rad(180)\n3.1415926535897931"
    pass

def degrees(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from radians to degrees.\n\nParameters\n----------\nx : array_like\n    Input array in radians.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray of floats\n    The corresponding degree values; if `out` was supplied this is a\n    reference to it.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nrad2deg : equivalent function\n\nExamples\n--------\nConvert a radian array to degrees\n\n>>> rad = np.arange(12.)*np.pi/6\n>>> np.degrees(rad)\narray([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n        270.,  300.,  330.])\n\n>>> out = np.zeros((rad.shape))\n>>> r = degrees(rad, out)\n>>> np.all(r == out)\nTrue"
    pass

def divide():
    "true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns a true division of the inputs, element-wise.\n\nInstead of the Python traditional 'floor division', this returns a true\ndivision.  True division adjusts the output type to present the best\nanswer, regardless of input types.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nThe floor division operator ``//`` was added in Python 2.2 making\n``//`` and ``/`` equivalent operators.  The default floor division\noperation of ``/`` can be replaced by true division with ``from\n__future__ import division``.\n\nIn Python 3.0, ``//`` is the floor division operator and ``/`` the\ntrue division operator.  The ``true_divide(x1, x2)`` function is\nequivalent to true division in Python.\n\nExamples\n--------\n>>> x = np.arange(5)\n>>> np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n>>> x/4\narray([0, 0, 0, 0, 1])\n>>> x//4\narray([0, 0, 0, 0, 1])\n\n>>> from __future__ import division\n>>> x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n>>> x//4\narray([0, 0, 0, 0, 1])"
    pass

def divmod(x1, x2, out1=None, out2=None, out=(None,None), *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn element-wise quotient and remainder simultaneously.\n\n.. versionadded:: 1.13.0\n\n``np.divmod(x, y)`` is equivalent to ``(x // y, x % y)``, but faster\nbecause it avoids redundant work. It is used to implement the Python\nbuilt-in function ``divmod`` on NumPy arrays.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout1 : ndarray\n    Element-wise quotient resulting from floor division.\n    This is a scalar if both `x1` and `x2` are scalars.\nout2 : ndarray\n    Element-wise remainder from floor division.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloor_divide : Equivalent to Python's ``//`` operator.\nremainder : Equivalent to Python's ``%`` operator.\nmodf : Equivalent to ``divmod(x, 1)`` for positive ``x`` with the return\n       values switched.\n\nExamples\n--------\n>>> np.divmod(np.arange(5), 3)\n(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))"
    pass

e = 2.718281828459045
def equal(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 == x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays of the same shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nnot_equal, greater_equal, less_equal, greater, less\n\nExamples\n--------\n>>> np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\n\nWhat is compared are values, not types. So an int (1) and an array of\nlength one can evaluate as True:\n\n>>> np.equal(1, np.ones(1))\narray([ True])"
    pass

euler_gamma = 0.5772156649015329
def exp(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'exp(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nCalculate the exponential of all elements in the input array.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise exponential of `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nexpm1 : Calculate ``exp(x) - 1`` for all elements in the array.\nexp2  : Calculate ``2**x`` for all elements in the array.\n\nNotes\n-----\nThe irrational number ``e`` is also known as Euler\'s number.  It is\napproximately 2.718281, and is the base of the natural logarithm,\n``ln`` (this means that, if :math:`x = \\ln y = \\log_e y`,\nthen :math:`e^x = y`. For real input, ``exp(x)`` is always positive.\n\nFor complex arguments, ``x = a + ib``, we can write\n:math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already\nknown (it is the real argument, described above).  The second term,\n:math:`e^{ib}`, is :math:`\\cos b + i \\sin b`, a function with\nmagnitude 1 and a periodic phase.\n\nReferences\n----------\n.. [1] Wikipedia, "Exponential function",\n       http://en.wikipedia.org/wiki/Exponential_function\n.. [2] M. Abramovitz and I. A. Stegun, "Handbook of Mathematical Functions\n       with Formulas, Graphs, and Mathematical Tables," Dover, 1964, p. 69,\n       http://www.math.sfu.ca/~cbm/aands/page_69.htm\n\nExamples\n--------\nPlot the magnitude and phase of ``exp(x)`` in the complex plane:\n\n>>> import matplotlib.pyplot as plt\n\n>>> x = np.linspace(-2*np.pi, 2*np.pi, 100)\n>>> xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n>>> out = np.exp(xx)\n\n>>> plt.subplot(121)\n>>> plt.imshow(np.abs(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap=\'gray\')\n>>> plt.title(\'Magnitude of exp(x)\')\n\n>>> plt.subplot(122)\n>>> plt.imshow(np.angle(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap=\'hsv\')\n>>> plt.title(\'Phase (angle) of exp(x)\')\n>>> plt.show()'
    pass

def exp2(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate `2**p` for all `p` in the input array.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Element-wise 2 to the power `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\npower\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\n\n\nExamples\n--------\n>>> np.exp2([2, 3])\narray([ 4.,  8.])"
    pass

def expm1(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCalculate ``exp(x) - 1`` for all elements in the array.\n\nParameters\n----------\nx : array_like\n   Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Element-wise exponential minus one: ``out = exp(x) - 1``.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlog1p : ``log(1 + x)``, the inverse of expm1.\n\n\nNotes\n-----\nThis function provides greater precision than ``exp(x) - 1``\nfor small values of ``x``.\n\nExamples\n--------\nThe true value of ``exp(1e-10) - 1`` is ``1.00000000005e-10`` to\nabout 32 significant digits. This example shows the superiority of\nexpm1 in this case.\n\n>>> np.expm1(1e-10)\n1.00000000005e-10\n>>> np.exp(1e-10) - 1\n1.000000082740371e-10"
    pass

def fabs(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the absolute values element-wise.\n\nThis function returns the absolute values (positive magnitude) of the\ndata in `x`. Complex values are not handled, use `absolute` to find the\nabsolute values of complex data.\n\nParameters\n----------\nx : array_like\n    The array of numbers for which the absolute values are required. If\n    `x` is a scalar, the result `y` will also be a scalar.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The absolute values of `x`, the returned values are always floats.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nabsolute : Absolute values including `complex` types.\n\nExamples\n--------\n>>> np.fabs(-1)\n1.0\n>>> np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])"
    pass

def float_power(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nFirst array elements raised to powers from second array, element-wise.\n\nRaise each base in `x1` to the positionally-corresponding power in `x2`.\n`x1` and `x2` must be broadcastable to the same shape. This differs from\nthe power function in that integers, float16, and float32  are promoted to\nfloats with a minimum precision of float64 so that the result is always\ninexact.  The intent is that the function will return a usable result for\nnegative powers and seldom overflow for positive powers.\n\n.. versionadded:: 1.12.0\n\nParameters\n----------\nx1 : array_like\n    The bases.\nx2 : array_like\n    The exponents.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The bases in `x1` raised to the exponents in `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\npower : power function that preserves type\n\nExamples\n--------\nCube each element in a list.\n\n>>> x1 = range(6)\n>>> x1\n[0, 1, 2, 3, 4, 5]\n>>> np.float_power(x1, 3)\narray([   0.,    1.,    8.,   27.,   64.,  125.])\n\nRaise the bases to different exponents.\n\n>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n>>> np.float_power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\nThe effect of broadcasting.\n\n>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n>>> x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n>>> np.float_power(x1, x2)\narray([[  0.,   1.,   8.,  27.,  16.,   5.],\n       [  0.,   1.,   8.,  27.,  16.,   5.]])"
    pass

def floor(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'floor(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nReturn the floor of the input, element-wise.\n\nThe floor of the scalar `x` is the largest integer `i`, such that\n`i <= x`.  It is often denoted as :math:`\\lfloor x \\rfloor`.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The floor of each element in `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nceil, trunc, rint\n\nNotes\n-----\nSome spreadsheet programs calculate the "floor-towards-zero", in other\nwords ``floor(-2.5) == -2``.  NumPy instead uses the definition of\n`floor` where `floor(-2.5) == -3`.\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])'
    pass

def floor_divide(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python ``//`` operator and pairs with the\nPython ``%`` (`remainder`), function so that ``b = a % b + b * (a // b)``\nup to roundoff.\n\nParameters\n----------\nx1 : array_like\n    Numerator.\nx2 : array_like\n    Denominator.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    y = floor(`x1`/`x2`)\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nremainder : Remainder complementary to floor_divide.\ndivmod : Simultaneous floor division and remainder.\ndivide : Standard division.\nfloor : Round a number to the nearest integer toward minus infinity.\nceil : Round a number to the nearest integer toward infinity.\n\nExamples\n--------\n>>> np.floor_divide(7,3)\n2\n>>> np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])"
    pass

def fmax(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise maximum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then the\nnon-nan element is returned. If both elements are NaNs then the first\nis returned.  The latter distinction is important for complex NaNs,\nwhich are defined as at least one of the real or imaginary parts being\na NaN. The net effect is that NaNs are ignored when possible.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. They must have\n    the same shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The maximum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfmin :\n    Element-wise minimum of two arrays, ignores NaNs.\nmaximum :\n    Element-wise maximum of two arrays, propagates NaNs.\namax :\n    The maximum value of an array along a given axis, propagates NaNs.\nnanmax :\n    The maximum value of an array along a given axis, ignores NaNs.\n\nminimum, amin, nanmin\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nThe fmax is equivalent to ``np.where(x1 >= x2, x1, x2)`` when neither\nx1 nor x2 are NaNs, but it is faster and does proper broadcasting.\n\nExamples\n--------\n>>> np.fmax([2, 3, 4], [1, 5, 2])\narray([ 2.,  5.,  4.])\n\n>>> np.fmax(np.eye(2), [0.5, 2])\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n>>> np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([  0.,   0.,  NaN])"
    pass

def fmin(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then the\nnon-nan element is returned. If both elements are NaNs then the first\nis returned.  The latter distinction is important for complex NaNs,\nwhich are defined as at least one of the real or imaginary parts being\na NaN. The net effect is that NaNs are ignored when possible.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. They must have\n    the same shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The minimum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfmax :\n    Element-wise maximum of two arrays, ignores NaNs.\nminimum :\n    Element-wise minimum of two arrays, propagates NaNs.\namin :\n    The minimum value of an array along a given axis, propagates NaNs.\nnanmin :\n    The minimum value of an array along a given axis, ignores NaNs.\n\nmaximum, amax, nanmax\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nThe fmin is equivalent to ``np.where(x1 <= x2, x1, x2)`` when neither\nx1 nor x2 are NaNs, but it is faster and does proper broadcasting.\n\nExamples\n--------\n>>> np.fmin([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n>>> np.fmin(np.eye(2), [0.5, 2])\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n>>> np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([  0.,   0.,  NaN])"
    pass

def fmod(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the element-wise remainder of division.\n\nThis is the NumPy implementation of the C library function fmod, the\nremainder has the same sign as the dividend `x1`. It is equivalent to\nthe Matlab(TM) ``rem`` function and should not be confused with the\nPython modulus operator ``x1 % x2``.\n\nParameters\n----------\nx1 : array_like\n    Dividend.\nx2 : array_like\n    Divisor.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : array_like\n    The remainder of the division of `x1` by `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nremainder : Equivalent to the Python ``%`` operator.\ndivide\n\nNotes\n-----\nThe result of the modulo operation for negative dividend and divisors\nis bound by conventions. For `fmod`, the sign of result is the sign of\nthe dividend, while for `remainder` the sign of the result is the sign\nof the divisor. The `fmod` function is equivalent to the Matlab(TM)\n``rem`` function.\n\nExamples\n--------\n>>> np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n>>> np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n\n>>> np.fmod([5, 3], [2, 2.])\narray([ 1.,  1.])\n>>> a = np.arange(-3, 3).reshape(3, 2)\n>>> a\narray([[-3, -2],\n       [-1,  0],\n       [ 1,  2]])\n>>> np.fmod(a, [2,2])\narray([[-1,  0],\n       [-1,  0],\n       [ 1,  0]])"
    pass

def frexp(x, out1=None, out2=None, out=(None,None), *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nDecompose the elements of x into mantissa and twos exponent.\n\nReturns (`mantissa`, `exponent`), where `x = mantissa * 2**exponent``.\nThe mantissa is lies in the open interval(-1, 1), while the twos\nexponent is a signed integer.\n\nParameters\n----------\nx : array_like\n    Array of numbers to be decomposed.\nout1 : ndarray, optional\n    Output array for the mantissa. Must have the same shape as `x`.\nout2 : ndarray, optional\n    Output array for the exponent. Must have the same shape as `x`.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nmantissa : ndarray\n    Floating values between -1 and 1.\n    This is a scalar if `x` is a scalar.\nexponent : ndarray\n    Integer exponents of 2.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nldexp : Compute ``y = x1 * 2**x2``, the inverse of `frexp`.\n\nNotes\n-----\nComplex dtypes are not supported, they will raise a TypeError.\n\nExamples\n--------\n>>> x = np.arange(9)\n>>> y1, y2 = np.frexp(x)\n>>> y1\narray([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n        0.5  ])\n>>> y2\narray([0, 1, 2, 2, 3, 3, 3, 3, 4])\n>>> y1 * 2**y2\narray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])"
    pass

def frompyfunc(func, nin, nout):
    "frompyfunc(func, nin, nout)\n\n    Takes an arbitrary Python function and returns a NumPy ufunc.\n\n    Can be used, for example, to add broadcasting to a built-in Python\n    function (see Examples section).\n\n    Parameters\n    ----------\n    func : Python function object\n        An arbitrary Python function.\n    nin : int\n        The number of input arguments.\n    nout : int\n        The number of objects returned by `func`.\n\n    Returns\n    -------\n    out : ufunc\n        Returns a NumPy universal function (``ufunc``) object.\n\n    See Also\n    --------\n    vectorize : evaluates pyfunc over input arrays using broadcasting rules of numpy\n\n    Notes\n    -----\n    The returned ufunc always returns PyObject arrays.\n\n    Examples\n    --------\n    Use frompyfunc to add broadcasting to the Python function ``oct``:\n\n    >>> oct_array = np.frompyfunc(oct, 1, 1)\n    >>> oct_array(np.array((10, 30, 100)))\n    array([012, 036, 0144], dtype=object)\n    >>> np.array((oct(10), oct(30), oct(100))) # for comparison\n    array(['012', '036', '0144'],\n          dtype='|S4')"
    pass

def gcd(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the greatest common divisor of ``|x1|`` and ``|x2|``\n\nParameters\n----------\nx1, x2 : array_like, int\n    Arrays of values\n\nReturns\n-------\ny : ndarray or scalar\n    The greatest common divisor of the absolute value of the inputs\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlcm : The lowest common multiple\n\nExamples\n--------\n>>> np.gcd(12, 20)\n4\n>>> np.gcd.reduce([15, 25, 35])\n5\n>>> np.gcd(np.arange(6), 20)\narray([20,  1,  2,  1,  4,  5])"
    pass

def geterrobj():
    'geterrobj()\n\n    Return the current object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in NumPy. `geterrobj` is used internally by the other\n    functions that get and set error handling behavior (`geterr`, `seterr`,\n    `geterrcall`, `seterrcall`).\n\n    Returns\n    -------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for "invalid", "under", "over", and\n        "divide" (in that order). The printed string can be interpreted with\n\n        * 0 : \'ignore\'\n        * 1 : \'warn\'\n        * 2 : \'raise\'\n        * 3 : \'call\'\n        * 4 : \'print\'\n        * 5 : \'log\'\n\n    See Also\n    --------\n    seterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> np.geterrobj()  # first get the defaults\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print("Floating point error (%s), with flag %s" % (type, flag))\n    ...\n    >>> old_bufsize = np.setbufsize(20000)\n    >>> old_err = np.seterr(divide=\'raise\')\n    >>> old_handler = np.seterrcall(err_handler)\n    >>> np.geterrobj()\n    [20000, 2, <function err_handler at 0x91dcaac>]\n\n    >>> old_err = np.seterr(all=\'ignore\')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    \'0\'\n    >>> old_err = np.seterr(divide=\'warn\', over=\'log\', under=\'call\',\n                            invalid=\'print\')\n    >>> np.base_repr(np.geterrobj()[1], 8)\n    \'4351\''
    pass

def greater(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 > x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays.  If ``x1.shape != x2.shape``, they must be\n    broadcastable to a common shape (which may be the shape of one or\n    the other).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\n\nSee Also\n--------\ngreater_equal, less, less_equal, equal, not_equal\n\nExamples\n--------\n>>> np.greater([4,2],[2,2])\narray([ True, False])\n\nIf the inputs are ndarrays, then np.greater is equivalent to '>'.\n\n>>> a = np.array([4,2])\n>>> b = np.array([2,2])\n>>> a > b\narray([ True, False])"
    pass

def greater_equal(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 >= x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays.  If ``x1.shape != x2.shape``, they must be\n    broadcastable to a common shape (which may be the shape of one or\n    the other).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : bool or ndarray of bool\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngreater, less, less_equal, equal, not_equal\n\nExamples\n--------\n>>> np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])"
    pass

def heaviside(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'heaviside(x1, x2, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nCompute the Heaviside step function.\n\nThe Heaviside step function is defined as::\n\n                          0   if x1 < 0\n    heaviside(x1, x2) =  x2   if x1 == 0\n                          1   if x1 > 0\n\nwhere `x2` is often taken to be 0.5, but 0 and 1 are also sometimes used.\n\nParameters\n----------\nx1 : array_like\n    Input values.\nx2 : array_like\n    The value of the function when x1 is 0.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The output array, element-wise Heaviside step function of `x1`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\n.. versionadded:: 1.13.0\n\nReferences\n----------\n.. Wikipedia, "Heaviside step function",\n   https://en.wikipedia.org/wiki/Heaviside_step_function\n\nExamples\n--------\n>>> np.heaviside([-1.5, 0, 2.0], 0.5)\narray([ 0. ,  0.5,  1. ])\n>>> np.heaviside([-1.5, 0, 2.0], 1)\narray([ 0.,  1.,  1.])'
    pass

def hypot(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'hypot(x1, x2, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nGiven the "legs" of a right triangle, return its hypotenuse.\n\nEquivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or\n`x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),\nit is broadcast for use with each element of the other argument.\n(See Examples)\n\nParameters\n----------\nx1, x2 : array_like\n    Leg of the triangle(s).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nz : ndarray\n    The hypotenuse of the triangle(s).\n    This is a scalar if both `x1` and `x2` are scalars.\n\nExamples\n--------\n>>> np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\nExample showing broadcast of scalar_like argument:\n\n>>> np.hypot(3*np.ones((3, 3)), [4])\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])'
    pass

def invert(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'invert(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nCompute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ``~``.\n\nFor signed integer inputs, the two\'s complement is returned.  In a\ntwo\'s-complement system negative numbers are represented by the two\'s\ncomplement of the absolute value. This is the most common method of\nrepresenting signed integers on computers [1]_. A N-bit\ntwo\'s-complement system can represent every integer in the range\n:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\nParameters\n----------\nx : array_like\n    Only integer and boolean types are handled.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nbitwise_and, bitwise_or, bitwise_xor\nlogical_not\nbinary_repr :\n    Return the binary representation of the input number as a string.\n\nNotes\n-----\n`bitwise_not` is an alias for `invert`:\n\n>>> np.bitwise_not is np.invert\nTrue\n\nReferences\n----------\n.. [1] Wikipedia, "Two\'s complement",\n    http://en.wikipedia.org/wiki/Two\'s_complement\n\nExamples\n--------\nWe\'ve seen that 13 is represented by ``00001101``.\nThe invert or bit-wise NOT of 13 is then:\n\n>>> np.invert(np.array([13], dtype=uint8))\narray([242], dtype=uint8)\n>>> np.binary_repr(x, width=8)\n\'00001101\'\n>>> np.binary_repr(242, width=8)\n\'11110010\'\n\nThe result depends on the bit-width:\n\n>>> np.invert(np.array([13], dtype=uint16))\narray([65522], dtype=uint16)\n>>> np.binary_repr(x, width=16)\n\'0000000000001101\'\n>>> np.binary_repr(65522, width=16)\n\'1111111111110010\'\n\nWhen using signed integer types the result is the two\'s complement of\nthe result for the unsigned type:\n\n>>> np.invert(np.array([13], dtype=int8))\narray([-14], dtype=int8)\n>>> np.binary_repr(-14, width=8)\n\'11110010\'\n\nBooleans are accepted as well:\n\n>>> np.invert(array([True, False]))\narray([False,  True])'
    pass

def isfinite(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for finiteness (not infinity or not Not a Number).\n\nThe result is returned as a boolean array.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray, bool\n    True where ``x`` is not positive infinity, negative infinity,\n    or NaN; false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisinf, isneginf, isposinf, isnan\n\nNotes\n-----\nNot a Number, positive infinity and negative infinity are considered\nto be non-finite.\n\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.  Errors result if the\nsecond argument is also supplied when `x` is a scalar input, or if\nfirst and second arguments have different shapes.\n\nExamples\n--------\n>>> np.isfinite(1)\nTrue\n>>> np.isfinite(0)\nTrue\n>>> np.isfinite(np.nan)\nFalse\n>>> np.isfinite(np.inf)\nFalse\n>>> np.isfinite(np.NINF)\nFalse\n>>> np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isfinite(x, y)\narray([0, 1, 0])\n>>> y\narray([0, 1, 0])"
    pass

def isinf(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for positive or negative infinity.\n\nReturns a boolean array of the same shape as `x`, True where ``x ==\n+/-inf``, otherwise False.\n\nParameters\n----------\nx : array_like\n    Input values\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : bool (scalar) or boolean ndarray\n    True where ``x`` is positive or negative infinity, false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisneginf, isposinf, isnan, isfinite\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\n\nErrors result if the second argument is supplied when the first\nargument is a scalar, or if the first and second arguments have\ndifferent shapes.\n\nExamples\n--------\n>>> np.isinf(np.inf)\nTrue\n>>> np.isinf(np.nan)\nFalse\n>>> np.isinf(np.NINF)\nTrue\n>>> np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False])\n\n>>> x = np.array([-np.inf, 0., np.inf])\n>>> y = np.array([2, 2, 2])\n>>> np.isinf(x, y)\narray([1, 0, 1])\n>>> y\narray([1, 0, 1])"
    pass

def isnan(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for NaN and return result as a boolean array.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    True where ``x`` is NaN, false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisinf, isneginf, isposinf, isfinite, isnat\n\nNotes\n-----\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\n\nExamples\n--------\n>>> np.isnan(np.nan)\nTrue\n>>> np.isnan(np.inf)\nFalse\n>>> np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False])"
    pass

def isnat(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'isnat(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nTest element-wise for NaT (not a time) and return result as a boolean array.\n\nParameters\n----------\nx : array_like\n    Input array with datetime or timedelta data type.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    True where ``x`` is NaT, false otherwise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nisnan, isinf, isneginf, isposinf, isfinite\n\nExamples\n--------\n>>> np.isnat(np.datetime64("NaT"))\nTrue\n>>> np.isnat(np.datetime64("2016-01-01"))\nFalse\n>>> np.isnat(np.array(["NaT", "2016-01-01"], dtype="datetime64[ns]"))\narray([ True, False])'
    pass

def lcm(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns the lowest common multiple of ``|x1|`` and ``|x2|``\n\nParameters\n----------\nx1, x2 : array_like, int\n    Arrays of values\n\nReturns\n-------\ny : ndarray or scalar\n    The lowest common multiple of the absolute value of the inputs\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngcd : The greatest common divisor\n\nExamples\n--------\n>>> np.lcm(12, 20)\n60\n>>> np.lcm.reduce([3, 12, 20])\n60\n>>> np.lcm.reduce([40, 12, 20])\n120\n>>> np.lcm(np.arange(6), 20)\narray([ 0, 20, 20, 60, 20, 20])"
    pass

def ldexp(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns x1 * 2**x2, element-wise.\n\nThe mantissas `x1` and twos exponents `x2` are used to construct\nfloating point numbers ``x1 * 2**x2``.\n\nParameters\n----------\nx1 : array_like\n    Array of multipliers.\nx2 : array_like, int\n    Array of twos exponents.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The result of ``x1 * 2**x2``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfrexp : Return (y1, y2) from ``x = y1 * 2**y2``, inverse to `ldexp`.\n\nNotes\n-----\nComplex dtypes are not supported, they will raise a TypeError.\n\n`ldexp` is useful as the inverse of `frexp`, if used by itself it is\nmore clear to simply use the expression ``x1 * 2**x2``.\n\nExamples\n--------\n>>> np.ldexp(5, np.arange(4))\narray([  5.,  10.,  20.,  40.], dtype=float32)\n\n>>> x = np.arange(6)\n>>> np.ldexp(*np.frexp(x))\narray([ 0.,  1.,  2.,  3.,  4.,  5.])"
    pass

def left_shift(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nShift the bits of an integer to the left.\n\nBits are shifted to the left by appending `x2` 0s at the right of `x1`.\nSince the internal representation of numbers is in binary format, this\noperation is equivalent to multiplying `x1` by ``2**x2``.\n\nParameters\n----------\nx1 : array_like of integer type\n    Input values.\nx2 : array_like of integer type\n    Number of zeros to append to `x1`. Has to be non-negative.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : array of integer type\n    Return `x1` with bits shifted `x2` times to the left.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nright_shift : Shift the bits of an integer to the right.\nbinary_repr : Return the binary representation of the input number\n    as a string.\n\nExamples\n--------\n>>> np.binary_repr(5)\n'101'\n>>> np.left_shift(5, 2)\n20\n>>> np.binary_repr(20)\n'10100'\n\n>>> np.left_shift(5, [1,2,3])\narray([10, 20, 40])"
    pass

def less(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 < x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays.  If ``x1.shape != x2.shape``, they must be\n    broadcastable to a common shape (which may be the shape of one or\n    the other).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngreater, less_equal, greater_equal, equal, not_equal\n\nExamples\n--------\n>>> np.less([1, 2], [2, 2])\narray([ True, False])"
    pass

def less_equal(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truth value of (x1 =< x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays.  If ``x1.shape != x2.shape``, they must be\n    broadcastable to a common shape (which may be the shape of one or\n    the other).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\ngreater, less, greater_equal, equal, not_equal\n\nExamples\n--------\n>>> np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])"
    pass

def log(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'log(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nNatural logarithm, element-wise.\n\nThe natural logarithm `log` is the inverse of the exponential function,\nso that `log(exp(x)) = x`. The natural logarithm is logarithm in base\n`e`.\n\nParameters\n----------\nx : array_like\n    Input value.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The natural logarithm of `x`, element-wise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlog10, log2, log1p, emath.log\n\nNotes\n-----\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `exp(z) = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log` always returns real output. For\neach value that cannot be expressed as a real number or infinity, it\nyields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",\n       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm\n\nExamples\n--------\n>>> np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])'
    pass

def log10(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'log10(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nReturn the base 10 logarithm of the input array, element-wise.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The logarithm to the base 10 of `x`, element-wise. NaNs are\n    returned where x is negative.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nemath.log10\n\nNotes\n-----\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `10**z = x`. The convention is to return the\n`z` whose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log10` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log10` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it.\n`log10` handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",\n       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm\n\nExamples\n--------\n>>> np.log10([1e-15, -3.])\narray([-15.,  NaN])'
    pass

def log1p(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'log1p(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nReturn the natural logarithm of one plus the input array, element-wise.\n\nCalculates ``log(1 + x)``.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    Natural logarithm of `1 + x`, element-wise.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nexpm1 : ``exp(x) - 1``, the inverse of `log1p`.\n\nNotes\n-----\nFor real-valued input, `log1p` is accurate also for `x` so small\nthat `1 + x == 1` in floating-point accuracy.\n\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `exp(z) = 1 + x`. The convention is to return\nthe `z` whose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log1p` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log1p` is a complex analytical function that\nhas a branch cut `[-inf, -1]` and is continuous from above on it.\n`log1p` handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\n\nReferences\n----------\n.. [1] M. Abramowitz and I.A. Stegun, "Handbook of Mathematical Functions",\n       10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n.. [2] Wikipedia, "Logarithm". http://en.wikipedia.org/wiki/Logarithm\n\nExamples\n--------\n>>> np.log1p(1e-99)\n1e-99\n>>> np.log(1 + 1e-99)\n0.0'
    pass

def log2(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nBase-2 logarithm of `x`.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    Base-2 logarithm of `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlog, log10, log1p, emath.log2\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nLogarithm is a multivalued function: for each `x` there is an infinite\nnumber of `z` such that `2**z = x`. The convention is to return the `z`\nwhose imaginary part lies in `[-pi, pi]`.\n\nFor real-valued input data types, `log2` always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields ``nan`` and sets the `invalid` floating point error flag.\n\nFor complex-valued input, `log2` is a complex analytical function that\nhas a branch cut `[-inf, 0]` and is continuous from above on it. `log2`\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\n\nExamples\n--------\n>>> x = np.array([0, 1, 2, 2**4])\n>>> np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n\n>>> xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n>>> np.log2(xi)\narray([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])"
    pass

def logaddexp(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nLogarithm of the sum of exponentiations of the inputs.\n\nCalculates ``log(exp(x1) + exp(x2))``. This function is useful in\nstatistics where the calculated probabilities of events may be so small\nas to exceed the range of normal floating point numbers.  In such cases\nthe logarithm of the calculated probability is stored. This function\nallows adding probabilities stored in such a fashion.\n\nParameters\n----------\nx1, x2 : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nresult : ndarray\n    Logarithm of ``exp(x1) + exp(x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nExamples\n--------\n>>> prob1 = np.log(1e-50)\n>>> prob2 = np.log(2.5e-50)\n>>> prob12 = np.logaddexp(prob1, prob2)\n>>> prob12\n-113.87649168120691\n>>> np.exp(prob12)\n3.5000000000000057e-50"
    pass

def logaddexp2(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nLogarithm of the sum of exponentiations of the inputs in base-2.\n\nCalculates ``log2(2**x1 + 2**x2)``. This function is useful in machine\nlearning when the calculated probabilities of events may be so small as\nto exceed the range of normal floating point numbers.  In such cases\nthe base-2 logarithm of the calculated probability can be used instead.\nThis function allows adding probabilities stored in such a fashion.\n\nParameters\n----------\nx1, x2 : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nresult : ndarray\n    Base-2 logarithm of ``2**x1 + 2**x2``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogaddexp: Logarithm of the sum of exponentiations of the inputs.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nExamples\n--------\n>>> prob1 = np.log2(1e-50)\n>>> prob2 = np.log2(2.5e-50)\n>>> prob12 = np.logaddexp2(prob1, prob2)\n>>> prob1, prob2, prob12\n(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n>>> 2**prob12\n3.4999999999999914e-50"
    pass

def logical_and(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 AND x2 element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays. `x1` and `x2` must be of the same shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    Boolean result with the same shape as `x1` and `x2` of the logical\n    AND operation on corresponding elements of `x1` and `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_or, logical_not, logical_xor\nbitwise_and\n\nExamples\n--------\n>>> np.logical_and(True, False)\nFalse\n>>> np.logical_and([True, False], [False, False])\narray([False, False])\n\n>>> x = np.arange(5)\n>>> np.logical_and(x>1, x<4)\narray([False, False,  True,  True, False])"
    pass

def logical_not(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of NOT x element-wise.\n\nParameters\n----------\nx : array_like\n    Logical NOT is applied to the elements of `x`.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : bool or ndarray of bool\n    Boolean result with the same shape as `x` of the NOT operation\n    on elements of `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlogical_and, logical_or, logical_xor\n\nExamples\n--------\n>>> np.logical_not(3)\nFalse\n>>> np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_not(x<3)\narray([False, False, False,  True,  True])"
    pass

def logical_or(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 OR x2 element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Logical OR is applied to the elements of `x1` and `x2`.\n    They have to be of the same shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or bool\n    Boolean result with the same shape as `x1` and `x2` of the logical\n    OR operation on elements of `x1` and `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_and, logical_not, logical_xor\nbitwise_or\n\nExamples\n--------\n>>> np.logical_or(True, False)\nTrue\n>>> np.logical_or([True, False], [False, False])\narray([ True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_or(x < 1, x > 3)\narray([ True, False, False, False,  True])"
    pass

def logical_xor(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nCompute the truth value of x1 XOR x2, element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Logical XOR is applied to the elements of `x1` and `x2`.  They must\n    be broadcastable to the same shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : bool or ndarray of bool\n    Boolean result of the logical XOR operation applied to the elements\n    of `x1` and `x2`; the shape is determined by whether or not\n    broadcasting of one or both arrays was required.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nlogical_and, logical_or, logical_not, bitwise_xor\n\nExamples\n--------\n>>> np.logical_xor(True, False)\nTrue\n>>> np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n\n>>> x = np.arange(5)\n>>> np.logical_xor(x < 1, x > 3)\narray([ True, False, False, False,  True])\n\nSimple example showing support of broadcasting\n\n>>> np.logical_xor(0, np.eye(2))\narray([[ True, False],\n       [False,  True]])"
    pass

def maximum(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise maximum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. They must have\n    the same shape, or shapes that can be broadcast to a single shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The maximum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nminimum :\n    Element-wise minimum of two arrays, propagates NaNs.\nfmax :\n    Element-wise maximum of two arrays, ignores NaNs.\namax :\n    The maximum value of an array along a given axis, propagates NaNs.\nnanmax :\n    The maximum value of an array along a given axis, ignores NaNs.\n\nfmin, amin, nanmin\n\nNotes\n-----\nThe maximum is equivalent to ``np.where(x1 >= x2, x1, x2)`` when\nneither x1 nor x2 are nans, but it is faster and does proper\nbroadcasting.\n\nExamples\n--------\n>>> np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n\n>>> np.maximum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n>>> np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\narray([ NaN,  NaN,  NaN])\n>>> np.maximum(np.Inf, 1)\ninf"
    pass

def minimum(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nElement-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays holding the elements to be compared. They must have\n    the same shape, or shapes that can be broadcast to a single shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The minimum of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nmaximum :\n    Element-wise maximum of two arrays, propagates NaNs.\nfmin :\n    Element-wise minimum of two arrays, ignores NaNs.\namin :\n    The minimum value of an array along a given axis, propagates NaNs.\nnanmin :\n    The minimum value of an array along a given axis, ignores NaNs.\n\nfmax, amax, nanmax\n\nNotes\n-----\nThe minimum is equivalent to ``np.where(x1 <= x2, x1, x2)`` when\nneither x1 nor x2 are NaNs, but it is faster and does proper\nbroadcasting.\n\nExamples\n--------\n>>> np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n>>> np.minimum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n>>> np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ NaN,  NaN,  NaN])\n>>> np.minimum(-np.Inf, 1)\n-inf"
    pass

def mod():
    "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor\n\nNotes\n-----\nReturns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)\nintegers.\n\nExamples\n--------\n>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])"
    pass

def modf(x, out1=None, out2=None, out=(None,None), *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the fractional and integral parts of an array, element-wise.\n\nThe fractional and integral parts are negative if the given number is\nnegative.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny1 : ndarray\n    Fractional part of `x`.\n    This is a scalar if `x` is a scalar.\ny2 : ndarray\n    Integral part of `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nFor integer input the return values are floats.\n\nSee Also\n--------\ndivmod : ``divmod(x, 1)`` is equivalent to ``modf`` with the return values\n         switched, except it always has a positive remainder.\n\nExamples\n--------\n>>> np.modf([0, 3.5])\n(array([ 0. ,  0.5]), array([ 0.,  3.]))\n>>> np.modf(-0.5)\n(-0.5, -0)"
    pass

def multiply(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nMultiply arguments element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays to be multiplied.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The product of `x1` and `x2`, element-wise. Returns a scalar if\n    both `x1` and `x2` are scalars.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nEquivalent to `x1` * `x2` in terms of array broadcasting.\n\nExamples\n--------\n>>> np.multiply(2.0, 4.0)\n8.0\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.multiply(x1, x2)\narray([[  0.,   1.,   4.],\n       [  0.,   4.,  10.],\n       [  0.,   7.,  16.]])"
    pass

def negative(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNumerical negative, element-wise.\n\nParameters\n----------\nx : array_like or scalar\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    Returned array or scalar: `y = -x`.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.negative([1.,-1.])\narray([-1.,  1.])"
    pass

def nextafter(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the next floating-point value after x1 towards x2, element-wise.\n\nParameters\n----------\nx1 : array_like\n    Values to find the next representable value of.\nx2 : array_like\n    The direction where to look for the next representable value of `x1`.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The next representable values of `x1` in the direction of `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nExamples\n--------\n>>> eps = np.finfo(np.float64).eps\n>>> np.nextafter(1, 2) == eps + 1\nTrue\n>>> np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]\narray([ True,  True])"
    pass

def not_equal(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn (x1 != x2) element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    Input arrays.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array, element-wise comparison of `x1` and `x2`.\n    Typically of type bool, unless ``dtype=object`` is passed.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nequal, greater, greater_equal, less, less_equal\n\nExamples\n--------\n>>> np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n>>> np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]])"
    pass

pi = 3.141592653589793
def positive(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nNumerical positive, element-wise.\n\n.. versionadded:: 1.13.0\n\nParameters\n----------\nx : array_like or scalar\n    Input array.\n\nReturns\n-------\ny : ndarray or scalar\n    Returned array or scalar: `y = +x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nEquivalent to `x.copy()`, but only defined for types that support\narithmetic."
    pass

def power(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nFirst array elements raised to powers from second array, element-wise.\n\nRaise each base in `x1` to the positionally-corresponding power in\n`x2`.  `x1` and `x2` must be broadcastable to the same shape. Note that an\ninteger type raised to a negative integer power will raise a ValueError.\n\nParameters\n----------\nx1 : array_like\n    The bases.\nx2 : array_like\n    The exponents.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The bases in `x1` raised to the exponents in `x2`.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloat_power : power function that promotes integers to float\n\nExamples\n--------\nCube each element in a list.\n\n>>> x1 = range(6)\n>>> x1\n[0, 1, 2, 3, 4, 5]\n>>> np.power(x1, 3)\narray([  0,   1,   8,  27,  64, 125])\n\nRaise the bases to different exponents.\n\n>>> x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n>>> np.power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\nThe effect of broadcasting.\n\n>>> x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n>>> x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n>>> np.power(x1, x2)\narray([[ 0,  1,  8, 27, 16,  5],\n       [ 0,  1,  8, 27, 16,  5]])"
    pass

def rad2deg(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from radians to degrees.\n\nParameters\n----------\nx : array_like\n    Angle in radians.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding angle in degrees.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\ndeg2rad : Convert angles from degrees to radians.\nunwrap : Remove large jumps in angle by wrapping.\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nrad2deg(x) is ``180 * x / pi``.\n\nExamples\n--------\n>>> np.rad2deg(np.pi/2)\n90.0"
    pass

def radians(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nConvert angles from degrees to radians.\n\nParameters\n----------\nx : array_like\n    Input array in degrees.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding radian values.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\ndeg2rad : equivalent function\n\nExamples\n--------\nConvert a degree array to radians\n\n>>> deg = np.arange(12.) * 30.\n>>> np.radians(deg)\narray([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n        5.23598776,  5.75958653])\n\n>>> out = np.zeros((deg.shape))\n>>> ret = np.radians(deg, out)\n>>> ret is out\nTrue"
    pass

def reciprocal(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the reciprocal of the argument, element-wise.\n\nCalculates ``1/x``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    Return array.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\n.. note::\n    This function is not designed to work with integers.\n\nFor integer arguments with absolute value larger than 1 the result is\nalways zero because of the way Python handles integer division.  For\ninteger zero the result is an overflow.\n\nExamples\n--------\n>>> np.reciprocal(2.)\n0.5\n>>> np.reciprocal([1, 2., 3.33])\narray([ 1.       ,  0.5      ,  0.3003003])"
    pass

def remainder(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn element-wise remainder of division.\n\nComputes the remainder complementary to the `floor_divide` function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor `x2`. The MATLAB function equivalent to ``np.remainder``\nis ``mod``.\n\n.. warning::\n\n    This should not be confused with:\n\n    * Python 3.7's `math.remainder` and C's ``remainder``, which\n      computes the IEEE remainder, which are the complement to\n      ``round(x1 / x2)``.\n    * The MATLAB ``rem`` function and or the C ``%`` operator which is the\n      complement to ``int(x1 / x2)``.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The element-wise remainder of the quotient ``floor_divide(x1, x2)``.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nfloor_divide : Equivalent of Python ``//`` operator.\ndivmod : Simultaneous floor division and remainder.\nfmod : Equivalent of the MATLAB ``rem`` function.\ndivide, floor\n\nNotes\n-----\nReturns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)\nintegers.\n\nExamples\n--------\n>>> np.remainder([4, 7], [2, 3])\narray([0, 1])\n>>> np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])"
    pass

def right_shift(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nShift the bits of an integer to the right.\n\nBits are shifted to the right `x2`.  Because the internal\nrepresentation of numbers is in binary format, this operation is\nequivalent to dividing `x1` by ``2**x2``.\n\nParameters\n----------\nx1 : array_like, int\n    Input values.\nx2 : array_like, int\n    Number of bits to remove at the right of `x1`.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray, int\n    Return `x1` with bits shifted `x2` times to the right.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nSee Also\n--------\nleft_shift : Shift the bits of an integer to the left.\nbinary_repr : Return the binary representation of the input number\n    as a string.\n\nExamples\n--------\n>>> np.binary_repr(10)\n'1010'\n>>> np.right_shift(10, 1)\n5\n>>> np.binary_repr(5)\n'101'\n\n>>> np.right_shift(10, [1,2,3])\narray([5, 2, 1])"
    pass

def rint(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nRound elements of the array to the nearest integer.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Output array is same shape and type as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nceil, floor, trunc\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.rint(a)\narray([-2., -2., -0.,  0.,  2.,  2.,  2.])"
    pass

def seterrobj(errobj):
    'seterrobj(errobj)\n\n    Set the object that defines floating-point error handling.\n\n    The error object contains all information that defines the error handling\n    behavior in NumPy. `seterrobj` is used internally by the other\n    functions that set error handling behavior (`seterr`, `seterrcall`).\n\n    Parameters\n    ----------\n    errobj : list\n        The error object, a list containing three elements:\n        [internal numpy buffer size, error mask, error callback function].\n\n        The error mask is a single integer that holds the treatment information\n        on all four floating point errors. The information for each error type\n        is contained in three bits of the integer. If we print it in base 8, we\n        can see what treatment is set for "invalid", "under", "over", and\n        "divide" (in that order). The printed string can be interpreted with\n\n        * 0 : \'ignore\'\n        * 1 : \'warn\'\n        * 2 : \'raise\'\n        * 3 : \'call\'\n        * 4 : \'print\'\n        * 5 : \'log\'\n\n    See Also\n    --------\n    geterrobj, seterr, geterr, seterrcall, geterrcall\n    getbufsize, setbufsize\n\n    Notes\n    -----\n    For complete documentation of the types of floating-point exceptions and\n    treatment options, see `seterr`.\n\n    Examples\n    --------\n    >>> old_errobj = np.geterrobj()  # first get the defaults\n    >>> old_errobj\n    [10000, 0, None]\n\n    >>> def err_handler(type, flag):\n    ...     print("Floating point error (%s), with flag %s" % (type, flag))\n    ...\n    >>> new_errobj = [20000, 12, err_handler]\n    >>> np.seterrobj(new_errobj)\n    >>> np.base_repr(12, 8)  # int for divide=4 (\'print\') and over=1 (\'warn\')\n    \'14\'\n    >>> np.geterr()\n    {\'over\': \'warn\', \'divide\': \'print\', \'invalid\': \'ignore\', \'under\': \'ignore\'}\n    >>> np.geterrcall() is err_handler\n    True'
    pass

def sign(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns an element-wise indication of the sign of a number.\n\nThe `sign` function returns ``-1 if x < 0, 0 if x==0, 1 if x > 0``.  nan\nis returned for nan inputs.\n\nFor complex inputs, the `sign` function returns\n``sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j``.\n\ncomplex(nan, 0) is returned for complex nan inputs.\n\nParameters\n----------\nx : array_like\n    Input values.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The sign of `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nThere is more than one definition of sign in common use for complex\nnumbers.  The definition used here is equivalent to :math:`x/\\sqrt{x*x}`\nwhich is different from a common alternative, :math:`x/|x|`.\n\nExamples\n--------\n>>> np.sign([-5., 4.5])\narray([-1.,  1.])\n>>> np.sign(0)\n0\n>>> np.sign(5-2j)\n(1+0j)"
    pass

def signbit(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns element-wise True where signbit is set (less than zero).\n\nParameters\n----------\nx : array_like\n    The input value(s).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nresult : ndarray of bool\n    Output array, or reference to `out` if that was supplied.\n    This is a scalar if `x` is a scalar.\n\nExamples\n--------\n>>> np.signbit(-1.2)\nTrue\n>>> np.signbit(np.array([1, -2.3, 2.1]))\narray([False,  True, False])"
    pass

def sin(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nTrigonometric sine, element-wise.\n\nParameters\n----------\nx : array_like\n    Angle, in radians (:math:`2 \\pi` rad equals 360 degrees).\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : array_like\n    The sine of each element of x.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\narcsin, sinh, cos\n\nNotes\n-----\nThe sine is one of the fundamental functions of trigonometry (the\nmathematical study of triangles).  Consider a circle of radius 1\ncentered on the origin.  A ray comes in from the :math:`+x` axis, makes\nan angle at the origin (measured counter-clockwise from that axis), and\ndeparts from the origin.  The :math:`y` coordinate of the outgoing\nray's intersection with the unit circle is the sine of that angle.  It\nranges from -1 for :math:`x=3\\pi / 2` to +1 for :math:`\\pi / 2.`  The\nfunction has zeroes where the angle is a multiple of :math:`\\pi`.\nSines of angles between :math:`\\pi` and :math:`2\\pi` are negative.\nThe numerous properties of the sine and related functions are included\nin any standard trigonometry text.\n\nExamples\n--------\nPrint sine of one angle:\n\n>>> np.sin(np.pi/2.)\n1.0\n\nPrint sines of an array of angles given in degrees:\n\n>>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\narray([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\n\nPlot the sine function:\n\n>>> import matplotlib.pylab as plt\n>>> x = np.linspace(-np.pi, np.pi, 201)\n>>> plt.plot(x, np.sin(x))\n>>> plt.xlabel('Angle [rad]')\n>>> plt.ylabel('sin(x)')\n>>> plt.axis('tight')\n>>> plt.show()"
    pass

def sinh(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'sinh(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nHyperbolic sine, element-wise.\n\nEquivalent to ``1/2 * (np.exp(x) - np.exp(-x))`` or\n``-1j * np.sin(1j*x)``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding hyperbolic sine values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972, pg. 83.\n\nExamples\n--------\n>>> np.sinh(0)\n0.0\n>>> np.sinh(np.pi*1j/2)\n1j\n>>> np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n>>> # Discrepancy due to vagaries of floating point arithmetic.\n\n>>> # Example of providing the optional output parameter\n>>> out2 = np.sinh([0.1], out1)\n>>> out2 is out1\nTrue\n\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.sinh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape'
    pass

def spacing(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the distance between x and the nearest adjacent number.\n\nParameters\n----------\nx : array_like\n    Values to find the spacing of.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    The spacing of values of `x`.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIt can be considered as a generalization of EPS:\n``spacing(np.float64(1)) == np.finfo(np.float64).eps``, and there\nshould not be any representable number between ``x + spacing(x)`` and\nx for any finite x.\n\nSpacing of +- inf and NaN is NaN.\n\nExamples\n--------\n>>> np.spacing(1) == np.finfo(np.float64).eps\nTrue"
    pass

def sqrt(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'sqrt(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nReturn the non-negative square-root of an array, element-wise.\n\nParameters\n----------\nx : array_like\n    The values whose square-roots are required.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    An array of the same shape as `x`, containing the positive\n    square-root of each element in `x`.  If any element in `x` is\n    complex, a complex array is returned (and the square-roots of\n    negative reals are calculated).  If all of the elements in `x`\n    are real, so is `y`, with negative elements returning ``nan``.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nlib.scimath.sqrt\n    A version which returns complex numbers when given negative reals.\n\nNotes\n-----\n*sqrt* has--consistent with common convention--as its branch cut the\nreal "interval" [`-inf`, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.\n\nExamples\n--------\n>>> np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n>>> np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n>>> np.sqrt([4, -1, numpy.inf])\narray([  2.,  NaN,  Inf])'
    pass

def square(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the element-wise square of the input.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    Element-wise `x*x`, of the same shape and dtype as `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nnumpy.linalg.matrix_power\nsqrt\npower\n\nExamples\n--------\n>>> np.square([-1j, 1])\narray([-1.-0.j,  1.+0.j])"
    pass

def subtract(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nSubtract arguments, element-wise.\n\nParameters\n----------\nx1, x2 : array_like\n    The arrays to be subtracted from each other.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The difference of `x1` and `x2`, element-wise.\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nEquivalent to ``x1 - x2`` in terms of array broadcasting.\n\nExamples\n--------\n>>> np.subtract(1.0, 4.0)\n-3.0\n\n>>> x1 = np.arange(9.0).reshape((3, 3))\n>>> x2 = np.arange(3.0)\n>>> np.subtract(x1, x2)\narray([[ 0.,  0.,  0.],\n       [ 3.,  3.,  3.],\n       [ 6.,  6.,  6.]])"
    pass

def tan(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'tan(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nCompute tangent element-wise.\n\nEquivalent to ``np.sin(x)/np.cos(x)`` element-wise.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding tangent values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.\n\nExamples\n--------\n>>> from math import pi\n>>> np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n>>>\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out2 = np.cos([0.1], out1)\n>>> out2 is out1\nTrue\n>>>\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape'
    pass

def tanh(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    'tanh(x, /, out=None, *, where=True, casting=\'same_kind\', order=\'K\', dtype=None, subok=True[, signature, extobj])\n\nCompute hyperbolic tangent element-wise.\n\nEquivalent to ``np.sinh(x)/np.cosh(x)`` or ``-1j * np.tan(1j*x)``.\n\nParameters\n----------\nx : array_like\n    Input array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    The corresponding hyperbolic tangent values.\n    This is a scalar if `x` is a scalar.\n\nNotes\n-----\nIf `out` is provided, the function writes the result into it,\nand returns a reference to `out`.  (See Examples)\n\nReferences\n----------\n.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\n       New York, NY: Dover, 1972, pg. 83.\n       http://www.math.sfu.ca/~cbm/aands/\n\n.. [2] Wikipedia, "Hyperbolic function",\n       http://en.wikipedia.org/wiki/Hyperbolic_function\n\nExamples\n--------\n>>> np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n\n>>> # Example of providing the optional output parameter illustrating\n>>> # that what is returned is a reference to said parameter\n>>> out2 = np.tanh([0.1], out1)\n>>> out2 is out1\nTrue\n\n>>> # Example of ValueError due to provision of shape mis-matched `out`\n>>> np.tanh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\nValueError: invalid return array shape'
    pass

def true_divide(x1, x2, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturns a true division of the inputs, element-wise.\n\nInstead of the Python traditional 'floor division', this returns a true\ndivision.  True division adjusts the output type to present the best\nanswer, regardless of input types.\n\nParameters\n----------\nx1 : array_like\n    Dividend array.\nx2 : array_like\n    Divisor array.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\nout : ndarray or scalar\n    This is a scalar if both `x1` and `x2` are scalars.\n\nNotes\n-----\nThe floor division operator ``//`` was added in Python 2.2 making\n``//`` and ``/`` equivalent operators.  The default floor division\noperation of ``/`` can be replaced by true division with ``from\n__future__ import division``.\n\nIn Python 3.0, ``//`` is the floor division operator and ``/`` the\ntrue division operator.  The ``true_divide(x1, x2)`` function is\nequivalent to true division in Python.\n\nExamples\n--------\n>>> x = np.arange(5)\n>>> np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n>>> x/4\narray([0, 0, 0, 0, 1])\n>>> x//4\narray([0, 0, 0, 0, 1])\n\n>>> from __future__ import division\n>>> x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n>>> x//4\narray([0, 0, 0, 0, 1])"
    pass

def trunc(x, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None):
    "trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])\n\nReturn the truncated value of the input, element-wise.\n\nThe truncated value of the scalar `x` is the nearest integer `i` which\nis closer to zero than `x` is. In short, the fractional part of the\nsigned number `x` is discarded.\n\nParameters\n----------\nx : array_like\n    Input data.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or `None`,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    Values of True indicate to calculate the ufunc at that position, values\n    of False indicate to leave the value in the output alone.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray or scalar\n    The truncated value of each element in `x`.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nceil, floor, rint\n\nNotes\n-----\n.. versionadded:: 1.3.0\n\nExamples\n--------\n>>> a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n>>> np.trunc(a)\narray([-1., -1., -0.,  0.,  1.,  1.,  2.])"
    pass

